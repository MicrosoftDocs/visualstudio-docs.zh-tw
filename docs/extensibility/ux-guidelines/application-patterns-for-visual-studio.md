---
title: Visual Studio 的應用程式模式 |Microsoft Docs
description: 瞭解文件視窗、工具視窗和非強制回應對話方塊之間的差異，包括 Visual Studio 的新功能的視窗使用模式。
ms.custom: SEO-VS-2020
ms.date: 04/26/2017
ms.topic: conceptual
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
author: leslierichardson95
ms.author: lerich
manager: jmartens
ms.workload:
- vssdk
ms.openlocfilehash: 7b19d60294431a08fa26f11bf58606893f392cd1
ms.sourcegitcommit: f2916d8fd296b92cc402597d1d1eecda4f6cccbf
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/25/2021
ms.locfileid: "105060233"
---
# <a name="application-patterns-for-visual-studio"></a>適用於 Visual Studio 的應用程式模式
## <a name="window-interactions"></a><a name="BKMK_WindowInteractions"></a> 視窗互動

### <a name="overview"></a>概觀
Visual Studio 中使用的兩個主視窗類型是檔編輯器和工具視窗。 很罕見，但可能是大型的非強制回應對話方塊。 雖然它們在 shell 中都是無模式的，但它們的模式基本上是不同的。 本節涵蓋文件視窗、工具視窗和非強制回應對話方塊之間的差異。 [對話方塊中涵蓋](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs)強制回應對話方塊模式。

### <a name="comparing-window-usage-patterns"></a>比較視窗使用模式
**檔視窗** 幾乎一律會顯示在檔中。 如此一來，檔編輯器就會有「中心階段」來排列補充工具視窗。

**工具視窗** 最常顯示為針對 IDE 邊緣折迭的另一個小型視窗。 這可以是可見、隱藏或自動隱藏。 不過，有時會在檔中顯示工具視窗，方法是取消核取視窗的 **視窗/** 停駐屬性。 這會產生更多房地產，但也是常見的設計決策：當您嘗試整合至 Visual Studio 時，您必須決定您的功能是否應該顯示工具視窗或文件視窗。

在 Visual Studio 中，不建議非 **強制回應對話方塊**。 大部分的非強制回應對話方塊都是依定義、浮動工具視窗，而且應該以這種方式執行。 當固定在 shell 側邊的一般工具視窗大小太過限制時，就可以使用非強制回應對話方塊。 當使用者可能會將對話移至次要監視器時，也可以使用它們。

請仔細考慮您需要的容器類型。 UI 設計的常見使用模式考慮如下表所示。

||文件視窗|工具視窗|非強制回應對話方塊|
|-|---------------------|-----------------|---------------------|
| **位置** | 一律定位於檔中，不會停駐在 IDE 的邊緣周圍。 它可以「提取」，使其與主要 shell 分開浮動。 | 通常會定位在 IDE 邊緣周圍，但可以自訂為浮動、自動隱藏 (固定) ，或停駐在檔中。|與 IDE 不同的大型浮動視窗。 |
| **認可模型** | *延遲認可*<br /><br /> 為了將資料儲存在檔中，使用者必須發出 [ **&gt; 儲存** 盤案]、[ **另存** 新檔] 或 [ **全部儲存** ] 命令。 文件視窗具有「變動總數」中資料的概念，然後再認可到其中一個「儲存」命令。 關閉文件視窗時，會將所有內容儲存到磁片或遺失。 | *立即認可*<br /><br /> 沒有儲存模型。 針對輔助編輯檔案的偵測器工具視窗，檔案必須在使用中的編輯器或設計工具中開啟，而且編輯器或設計工具會擁有儲存。 | *延遲或立即認可*<br /><br /> 最常見的情況是，大型非強制回應對話方塊需要採取動作來認可變更，並允許「取消」作業，以回復在對話會話中所做的任何變更。  這會區分非強制回應對話方塊與該工具視窗中的工具視窗一律具有立即認可模型。 |
| **可見度** | *開啟/建立 (檔案) 並關閉*<br /><br /> 開啟文件視窗是透過開啟現有檔或使用範本來建立新檔來完成。 沒有 "Open \<specific editor> " 命令。 | *隱藏和顯示*<br /><br /> 可以隱藏或顯示單一實例工具視窗。 工具視窗內的內容和狀態會保存，無論是在 view 或 hidden 中。 多實例工具視窗可以關閉，也可以隱藏。 當多實例工具視窗關閉時，會捨棄工具視窗內的內容和狀態。 | *從命令啟動*<br /><br /> 對話是從以工作為基礎的命令啟動。 |
| **執行個體** | *多重實例*<br /><br /> 您可以同時開啟數個編輯器並編輯不同的檔案，而某些編輯器也允許在多個編輯器中開啟相同的檔案， (使用視窗的 [ **&gt; 新增視窗]** 命令) 。<br /><br /> 單一編輯器可能會同時 (專案設計工具) 編輯一或多個檔案。 | *單一或多個實例*<br /><br /> 在屬性瀏覽器中，內容會變更以反映內容 () 或將焦點/內容推送至其他 windows (工作清單，方案總管) 。<br /><br /> 單一實例和多重實例工具視窗都應與使用中文件視窗相關聯，除非令人信服的原因不是。 | *單一實例* |
| **範例** | **文本** 編輯器，例如程式碼編輯器<br /><br /> **設計** 介面，例如表單設計工具或模型化介面<br /><br /> **控制項類似于對話方塊的控制項版面** 配置，例如資訊清單設計工具 | **方案總管** 提供解決方案中所包含的方案和專案<br /><br /> **伺服器總管** 會提供使用者在視窗中選擇要開啟之伺服器和資料連線的階層式查看。 從資料庫階層開啟物件（例如查詢）時，會開啟文件視窗，讓使用者可以編輯查詢。<br /><br /> **屬性瀏覽器** 會顯示在文件視窗或其他工具視窗中所選取物件的屬性。 這些屬性會以階層式格線視圖或複雜對話方塊的控制項來呈現，並可讓使用者設定這些屬性的值。 | |

## <a name="tool-windows"></a><a name="BKMK_ToolWindows"></a> 工具視窗

### <a name="overview"></a>概觀
工具視窗支援使用者在文件視窗中所發生的工作。 您可以使用它們來顯示階層，代表 Visual Studio 提供和可以操作的基本根物件。

在 IDE 中考慮新的工具視窗時，作者應：

- 使用工作適當的現有工具視窗，而不是使用類似的功能建立新的工具視窗。 如果新的工具視窗提供的「工具」功能明顯不同，或無法整合到類似視窗的功能，或將現有視窗轉換成「旋轉中樞」，則應該只建立新的工具視窗。

- 如有需要，請在工具視窗的頂端使用標準的命令列。

- 與其他工具視窗中已存在的模式一致，以進行控制項呈現和鍵盤流覽。

- 與其他工具視窗中的控制項呈現一致。

- 讓檔專屬的工具視窗盡可能自動顯示，使其只在父檔啟用時才會出現。

- 確定) 的鍵盤 (支援箭號可流覽其視窗內容。

#### <a name="tool-window-states"></a>工具視窗狀態
Visual Studio 的工具視窗具有不同的狀態，其中有些是使用者啟動的 (，例如自動隱藏功能) 。 其他狀態（例如自動可見）允許工具視窗顯示在正確的內容中，並在不需要時隱藏。 總共有五個工具視窗狀態。

- 停駐 **/固定** 的工具視窗可以附加至檔區域的四個邊。 圖釘圖示會出現在工具視窗標題列中。 工具視窗可以在 shell 和其他工具視窗的邊緣水準或垂直停駐，也可以是索引標籤連結。

- **自動隱藏的** 工具視窗已取消固定。 您可以將視窗滑出，讓索引標籤 (使用工具視窗的名稱，以及在檔區域的邊緣) 圖示。 當使用者將滑鼠停留在索引標籤上時，工具視窗就會滑出。

- **自動可見** 的工具視窗會在另一段 UI （如編輯器）啟動或獲得焦點時自動出現。

- **浮動** 工具視窗會將滑鼠停留在 IDE 之外。 這適用于多監視器設定。

- 索引標籤 **式檔** 工具視窗可以停駐在檔中。 這適用于大型工具視窗，像是物件瀏覽器，需要比停駐到框架邊緣更多的房地產。

![Visual Studio 中的工具視窗狀態](../../extensibility/ux-guidelines/media/0702-01_toolwindowstates.png "0702-01_ToolWindowStates")<br />Visual Studio 中的工具視窗狀態

#### <a name="single-instance-and-multi-instance"></a>單一實例和多重實例
工具視窗可以是單一實例或多重實例。 某些單一實例工具視窗可能會與使用中的文件視窗相關聯，而多重實例工具視窗則不會。 多重實例工具視窗會藉由建立新的視窗實例來回應視窗的 [ **&gt; 新視窗]** 命令。 下圖說明當視窗的實例為使用中時，啟用新視窗命令的工具視窗：

![當視窗的實例為使用中時，工具視窗啟用 ' New Window ' 命令](../../extensibility/ux-guidelines/media/0702-02_toolwindowenablingcommand.png "0702-02_ToolWindowEnablingCommand")<br />當視窗的實例為使用中時，工具視窗啟用 ' New Window ' 命令

可以隱藏或顯示單一實例工具視窗，而多實例工具視窗則可以關閉，也可以隱藏。 所有工具視窗都可以停駐、索引標籤連結、浮動或設定為 Multiple-Document 介面 (MDI) 子視窗 (類似于文件視窗) 。 所有工具視窗都應該回應 [視窗] 功能表中適當的視窗管理命令：

![Visual Studio 視窗功能表中的視窗管理命令](../../extensibility/ux-guidelines/media/0702-03_windowmanagementcontrols.png "0702-03_WindowManagementControls")<br />Visual Studio 視窗功能表中的視窗管理命令

#### <a name="document-specific-tool-windows"></a>檔特定工具視窗
某些工具視窗的設計是根據指定的檔案類型來變更。 這些視窗會持續更新，以反映適用于 IDE 中活動文件視窗的功能。

[工具箱] 和 [檔大綱] 是其內容變更以反映選取之編輯器的工具視窗範例。 當編輯器的焦點不提供視窗的內容時，這些視窗會顯示浮水印。

#### <a name="navigable-list-tool-windows"></a>可瀏覽清單工具視窗
某些工具視窗會顯示使用者可以與之互動的可流覽專案清單。 在這種類型的視窗中，即使視窗處於非使用中狀態，也應該一律對清單中的目前專案提供意見反應。 此清單應該也會變更視窗中目前選取的專案，以回應 **GoToNextLocation** 和 **GoToPrevLocation** 命令

可導覽清單工具視窗的範例包括方案總管和 [尋找結果] 視窗。

### <a name="tool-window-types"></a>工具視窗類型

#### <a name="common-tool-windows-and-their-functions"></a>通用工具視窗及其功能

**階層式工具視窗**

| 工具視窗 | 函式 |
| --- | --- |
| 方案總管 | 階層式樹狀結構，可顯示專案、其他檔案和方案專案中包含的檔案清單。 專案內的專案顯示是由擁有專案類型的封裝所定義 (例如，以參考為基礎、以目錄為基礎或混合模式類型) 。 |
| 類別檢視 | 類別的階層式樹狀結構，以及工作集內的各種元素，與檔案本身無關。 |
| Server Explorer | 階層式樹狀結構，顯示方案中的所有伺服器和資料連線。 |
| 文件大綱 | 現用檔的階層式結構。 |

**方格工具視窗**

| 工具視窗 | 函式 |
| --- | --- |
| 屬性 | 此方格會顯示所選物件的屬性清單，以及用來編輯這些屬性的值選擇器。 |
| 工作清單 | 允許使用者建立/編輯/刪除工作和批註的方格。 |

**內容工具視窗**

| 工具視窗 | 函式 |
| --- | --- |
| Help | 此視窗可讓使用者從「如何」存取各種取得協助的方法。 影片至 MSDN 論壇。 |
| 動態說明 | 此工具視窗會顯示適用于目前選取範圍之說明主題的連結。 |
| 物件瀏覽器 | 兩欄的框架，其中包含左窗格中的階層式物件元件清單，以及右邊資料行中物件的屬性和方法。 |

**對話方塊工具視窗**

| 工具視窗 | 函式 |
| --- | --- |
| Find | 此對話方塊可讓使用者在方案內的各種檔案中尋找或尋找和取代。 |
| 進階尋找 | 此對話方塊可讓使用者在方案內的各種檔案中尋找或尋找和取代。 |

**其他工具視窗**

::: moniker range="vs-2017"

| 工具視窗 | 函式 |
| --- | --- |
| 工具箱 | 用來儲存將放置在設計介面上之元素的工具視窗，為所有設計工具提供一致的拖曳來源。 |
| 起始頁 | 要 Visual Studio 的使用者入口網站，可存取開發人員新聞的摘要、Visual Studio 說明和最近使用的專案。 使用者也可以建立自訂起始頁，方法是將 [Common7\IDE\StartPages Visual Studio program files] 目錄中的 StartPage .xaml 檔案複製 \" 到 Visual Studio [檔] 目錄中的 [StartPages] 資料夾，然後手動編輯 xaml 或在 Visual Studio 或其他程式碼編輯器中開啟。 |

::: moniker-end

::: moniker range=">=vs-2019"

| 工具視窗 | 函式 |
| --- | --- |
| 工具箱 | 用來儲存將放置在設計介面上之元素的工具視窗，為所有設計工具提供一致的拖曳來源。 |

::: moniker-end

**偵錯工具工具視窗**

| 工具視窗 | 函式 |
| --- | --- |
| 自動 ||
| 立即 ||
| 輸出 | 當您有要宣告的文字事件或狀態時，就可以使用 [輸出] 視窗。 |
| 記憶體 ||
| 中斷點 ||
| 執行中 ||
| 文件 ||
| 呼叫堆疊 ||
| 本機 ||
| 手錶 ||
| 反組譯碼 ||
| 暫存器 ||
| 執行緒 ||

## <a name="document-editor-conventions"></a><a name="BKMK_DocumentEditorConventions"></a> 檔編輯器慣例

### <a name="document-interactions"></a>檔互動
「檔妥善」是 IDE 內最大的空間，而且使用者通常會將其注意力集中于輔助工具視窗，以完成工作。 檔編輯器代表使用者在 Visual Studio 中開啟和儲存的基本工作單位。 它們保有與方案總管或其他作用中階層視窗系結的強大選擇。 使用者應該要能夠指向其中一個階層視窗，並知道檔的所在位置，以及與解決方案、專案或 Visual Studio 套件所提供的另一個根物件之間的關聯性。

檔編輯需要一致的使用者體驗。 若要讓使用者將焦點放在手邊的工作而非視窗管理和尋找命令，請選取最適合使用者工作的檔視圖策略，以編輯該檔案類型。

#### <a name="common-interactions-for-the-document-well"></a>檔的一般互動

- 在常見的 **新** 檔案中維持一致的互動模型，並 **開啟** 檔案體驗。

- 當文件視窗開啟時，更新相關視窗和功能表中的相關功能。

- 功能表命令會適當地整合至一般功能表，例如 **編輯**、 **格式化** 和 **流覽** 功能表。 如果有大量的特殊命令可供使用，則可以建立新的功能表。 只有當檔具有焦點時，才會顯示這個新功能表。

- 內嵌的工具列可能會放在編輯器的上方。 最好是讓另一個工具列出現在編輯器之外。

- 一律在方案總管或類似的 [作用中] 階層視窗中維護選取專案。

- 按兩下方案總管中的檔時，應該會執行與 **開啟** 相同的動作。

- 如果檔案類型可以使用一個以上的編輯器，使用者應該能夠使用 [ **開啟** 檔案] 對話方塊，以滑鼠右鍵按一下檔案，然後從快捷方式功能表選取 [ **開啟** 檔案]，在指定的檔案類型上覆寫或重設預設動作。

- 不要在檔中建立 wizard。

### <a name="user-expectations-for-specific-document-types"></a>特定檔案類型的使用者期望
檔編輯器有數種不同的基本類型，每個都有一組與相同類型的其他互動一致的互動。

- 以 **文字為基礎的編輯器：** 程式碼編輯器，記錄檔

- **設計介面：** WPF 表單設計工具，Windows forms

- **對話方塊樣式編輯器：** 專案屬性、資訊清單設計工具

- **模型設計師：** 工作流程設計工具、codemap、架構圖表、進展

另外還有數個使用檔的非編輯器類型。 雖然它們本身不會編輯檔，但需要遵循文件視窗的標準互動。

- **報表：** IntelliTrace 報告、Hyper-v 報表、profiler 報表

- **儀表板：** 診斷中樞

#### <a name="text-based-editors"></a>以文字為基礎的編輯器

- 檔會參與預覽索引標籤模型，讓您不需要開啟檔就能進行預覽。

- 檔的結構可能會在隨附的工具視窗內表示，例如檔大綱。

- IntelliSense (是否適當的) 將與其他程式碼編輯器一致地運作。

- 快顯或輔助 UI 會遵循類似于現有類似 UI 的類似樣式和模式，例如 CodeLens。

- 有關檔狀態的訊息會顯示在檔頂端的資訊列控制項中，或狀態列中。

- 使用者必須能夠使用 [ **工具] > [選項** ] 頁面（[共用字型] 和 [色彩] 頁面，或是編輯器特定的工具）來自訂字型和色彩的外觀。

#### <a name="design-surfaces"></a>設計介面

- 空白的設計工具應該會在介面上有一個表示如何開始使用的浮水印。

- 視圖切換機制將會遵循現有的模式，例如按兩下以開啟程式碼編輯器，或在文件視窗內提供索引標籤，以允許與這兩個窗格互動。

- 除非需要高度特定的工具視窗，否則您應該透過 [工具箱] 將專案加入至設計介面。

- 介面上的專案會遵循一致的選取模型。

- 內嵌工具列只包含檔專屬的命令，而不是一般的命令（例如 **儲存**）。

#### <a name="dialog-style-editors"></a>對話方塊樣式編輯器

- 控制項配置應遵循一般的對話版面配置慣例。

- 編輯器中的索引標籤不應符合檔索引標籤的外觀，它們應該符合兩個允許的內部索引標籤樣式之一。

- 使用者必須只能使用鍵盤與控制項互動;藉由啟用編輯器，並透過控制項或使用標準的助憶鍵進行 tab 鍵。

- 設計工具應該使用一般的儲存模型。 由於其他按鈕可能適用，因此不應該在介面上放置整體儲存或認可按鈕。

#### <a name="model-designers"></a>模型設計師

- 空白的設計工具應該會在介面上有一個表示如何開始使用的浮水印。

- 將專案加入至設計介面應該透過 [工具箱] 來完成。

- 介面上的專案會遵循一致的選取模型。

- 內嵌工具列只包含檔專屬的命令，而不是一般的命令（例如 **儲存**）。

- 圖例可能會顯示在表面上，也就是表示或浮水印。

- 使用者必須能夠使用 [ **工具] > [選項** ] 頁面（[共用字型] 和 [色彩] 頁面，或是編輯器特定的工具）來自訂字型/色彩的外觀。

#### <a name="reports"></a>報表

- 報表通常僅供資訊之用，不會參與儲存模型。 不過，它們可能包含互動，例如其他相關資訊的連結，或展開和折迭的區段。

- 介面上的大部分命令都應該是超連結，而不是按鈕。

- 配置應包含標頭，並遵循標準報表配置指導方針。

#### <a name="dashboards"></a>儀表板

- 儀表板本身沒有互動模型，但作為提供各種其他工具的方法。

- 它們不會參與儲存模型。

- 使用者必須能夠使用鍵盤來與控制項互動，方法是啟用編輯器，並透過控制項來定位，或使用標準的助憶鍵。

## <a name="dialogs"></a><a name="BKMK_Dialogs"></a> 對話 框

### <a name="introduction"></a>簡介
Visual Studio 中的對話通常會支援使用者工作的一個離散單位，然後加以關閉。

如果您已判斷需要對話方塊，您有三個選擇，依喜好設定順序：

1. 將您的功能整合到 Visual Studio 中的其中一個共用對話方塊。

2. 使用在現有類似對話方塊中找到的模式來建立您自己的對話方塊。

3. 建立新的對話方塊，並遵循互動和版面配置指導方針。

本節說明如何選擇 Visual Studio 工作流程內的正確對話方塊模式，以及對話設計的一般慣例。

### <a name="themes"></a>佈景主題
Visual Studio 中的對話方塊會遵循下列其中一種基本樣式：

#### <a name="standard-unthemed"></a>標準 (unthemed) 
大部分的對話方塊都是標準公用程式對話方塊，應該 unthemed。 請勿重新範本通用控制項，或嘗試建立具樣式的「新式」按鈕或控制項。 控制項和 chrome 外觀遵循 [適用于對話方塊的標準 Windows 桌面互動指導方針](/windows/desktop/uxguide/win-dialog-box)。

#### <a name="themed"></a>主題
特殊的「簽章」對話方塊可能有主題。 主題對話具有不同的外觀，也有一些與樣式相關聯的特殊互動模式。 只有在符合下列需求時，才會將您的對話方塊主題：

- 對話是常見的體驗，會經常或由許多使用者 (例如 [ **新增專案** ] 對話方塊中使用。

- 此對話方塊包含顯著的產品品牌要素 (例如，[ **帳戶設定** ] 對話方塊) 。

- 對話方塊會顯示為較大流程不可或缺的一部分，包括其他主題對話方塊 (例如，[ **加入已連接服務** ] 對話方塊) 。

- 對話是在升級或區分產品版本時扮演策略性角色之體驗的重要部分。

建立主題對話方塊時，請使用適當的環境色彩，並遵循正確的版面配置和互動模式。  (請參閱 [Visual Studio 的版面](../../extensibility/ux-guidelines/layout-for-visual-studio.md)配置。 ) 

### <a name="dialog-design"></a>對話方塊設計
設計完善的對話方塊會考慮下列元素：

- 支援的使用者工作

- 對話方塊文字樣式、語言和術語

- 控制項選擇和 UI 慣例

- 視覺效果版面配置規格和控制項對齊

- 存取鍵盤

#### <a name="content-organization"></a>內容組織
請考慮這些基本對話類型之間的差異：

- [簡單的對話方塊](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs) 會在單一強制回應視窗中顯示控制項。 簡報可能包含複雜控制項模式的變化，包括欄位選擇器或圖示列。

- 當一段 UI 包含多個控制項群組時，會使用多[層式對話方塊](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs)來充分發揮螢幕空間。 對話方塊的群組會透過索引標籤控制項、導覽清單控制項或按鈕來「分層」，讓使用者可以選擇在任何指定時刻看到的群組。

- 在完成工作的步驟中，可透過步驟的邏輯順序來引導使用者使用[嚮導](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards)。 順序面板中會提供一系列的選擇，有時會 ( 「分支」導入不同的工作流程，) 取決於上一個面板中所做的選擇。

#### <a name="simple-dialogs"></a><a name="BKMK_SimpleDialogs"></a> 簡單對話
簡單的對話是單一強制回應視窗中的控制項呈現。 這份簡報可能包含複雜控制項模式的變化，例如欄位選擇器。 針對簡單的對話，請遵循標準一般配置以及複雜控制項群組所需的任何特定版面配置。

![>建立強式名稱金鑰是 Visual Studio 中簡單對話的範例。](../../extensibility/ux-guidelines/media/0704-01_createstrongnamekey.png "0704-01_CreateStrongNameKey")<br />建立強式名稱金鑰是 Visual Studio 中簡單對話的範例。

#### <a name="layered-dialogs"></a><a name="BKMK_LayeredDialogs"></a> 分層對話
分層對話方塊包括索引標籤、儀表板和內嵌樹狀結構。 當單一 UI 中有多個控制項群組時，就會使用它們來最大化房地產。 群組會分層，讓使用者可以選擇要在任一時間查看的群組。

在最簡單的情況下，在群組之間切換的機制是一個索引標籤控制項。 有幾個替代方案可用。 請參閱優先順序和分層，以瞭解如何選擇最適當的樣式。

[ **工具 &gt; 選項** ] 對話方塊是使用內嵌樹狀結構的分層式對話方塊範例：

![工具 > 選項是 Visual Studio 中多層式對話方塊的範例。](../../extensibility/ux-guidelines/media/0704-02_toolsoptions.png "0704-02_ToolsOptions")<br />工具 > 選項是 Visual Studio 中多層式對話方塊的範例。

#### <a name="wizards"></a><a name="BKMK_Wizards"></a> 嚮導
當工作完成時，嚮導可透過步驟的邏輯順序來引導使用者。 順序面板中會提供一系列的選擇，使用者必須繼續執行每個步驟，才能繼續進行下一個步驟。 一旦有足夠的預設值，就會啟用 [ **完成]** 按鈕。

 強制回應的工作會用於：

- 包含分支，視使用者的選擇而定，會提供不同的路徑

- 包含步驟之間的相依性，其中後續步驟取決於上述步驟中的使用者輸入 (s) 

- UI 應該用來說明所提供的選項，以及每個步驟的可能結果，都是相當複雜的工作。

- 為交易式，需要在任何變更認可之前完整完成一組步驟

### <a name="common-conventions"></a>常見慣例
若要使用您的對話來達到最佳的設計和功能，請遵循對話方塊大小、位置、標準、控制項設定和對齊方式、UI 文字、標題列、控制項按鈕和存取金鑰的慣例。

如需版面配置特定的指導方針，請參閱 [Visual Studio 的版面](../../extensibility/ux-guidelines/layout-for-visual-studio.md)配置。

#### <a name="size"></a>大小
對話方塊應符合最小1024x768 螢幕解析度，而初始對話大小不應超過900x700 圖元。 對話方塊可以是可調整大小的，但不是必要條件。

可調整大小的對話方塊有兩個建議：

1. 大小下限是針對對話方塊所定義，該對話方塊會針對未裁剪的控制集進行優化，並進行調整以容納合理的當地語系化成長。

2. 使用者調整規模的大小會從會話持續保留到會話中。 例如，如果使用者將對話調整為150%，則後續的對話方塊啟動將會顯示在150%。

#### <a name="position"></a>位置
對話必須在第一次啟動時以中央顯示在 IDE 中。 不可調整大小之對話方塊的最後一個位置不需要保存，因此它們會顯示在後續啟動的中央。

針對可調整大小的對話，大小應該在後續啟動時保存。 針對可調整大小的強制回應對話方塊，不需要保存位置。 將其顯示在 IDE 中，可避免對話方塊在使用者的顯示設定變更時出現在無法預期或無法使用的位置。

對於可以重新置放的非強制回應對話方塊，使用者的位置應該在後續啟動時進行維護，因為對話可能經常用來做為較大工作流程不可或缺的一部分。

當對話必須產生其他對話方塊時，最上層的對話方塊應從父系向右和向下重迭，如此一來，使用者就能輕易地向下流覽至新位置。

#### <a name="modality"></a>形態
強制回應表示使用者必須先完成或取消對話方塊，才能繼續進行。 由於強制回應對話方塊會封鎖使用者與環境其他部分的互動，所以您的功能的工作流程應該盡可能謹慎地使用它們。 當需要強制回應作業時，Visual Studio 有許多共用對話方塊，可將您的功能整合到其中。 如果您必須建立新的對話，請遵循具有類似功能之現有對話方塊的互動模式。

當使用者需要一次執行兩個活動時（例如，在撰寫新程式碼時 **尋找** 和 **取代** ），對話方塊應為非模式，讓使用者可以輕鬆地在其間切換。 Visual Studio 通常會使用工具視窗來進行這類編輯器支援的連結工作。

#### <a name="control-configuration"></a>控制項設定
與現有的控制項設定一致，以在 Visual Studio 中達成相同的目的。

#### <a name="title-bars"></a>標題列

- 標題列中的文字必須反映啟動它的命令名稱。

- 對話方塊標題列中不應使用任何圖示。 如果系統需要的話，請使用 Visual Studio 標誌。

- 對話不應該有最小化或最大化按鈕。

- 標題列中的 [說明] 按鈕已被取代。 請勿將它們新增至新的對話方塊。 當其存在時，應該會啟動概念上與工作相關的說明主題。

  ![Visual Studio 對話方塊中標題列的指導方針](../../extensibility/ux-guidelines/media/0704-03_titlebarspecs.png "0704-03_TitleBarSpecs")<br />Visual Studio 對話方塊中標題列的指導方針

#### <a name="control-buttons"></a>控制項按鈕
一般情況下，[確定]、 **[****取消**] 和 [說明 **] 按鈕應該** 在對話方塊的右下角水準排列。 如果對話方塊底部有幾個其他按鈕會呈現視覺效果與控制項按鈕的混淆，則允許使用替代垂直堆疊。

![Visual Studio 對話方塊中控制項按鈕的可接受設定](../../extensibility/ux-guidelines/media/0704-04_controlbuttonconfig.png "0704-04_ControlButtonConfig")<br />Visual Studio 對話方塊中控制項按鈕的可接受設定

對話方塊必須包含預設控制項按鈕。 若要判斷最適合作為預設使用的命令，請從下列選項中選擇 (依優先順序) 順序列出：

- 選擇最安全且最安全的命令作為預設值。 這表示選擇最有可能防止資料遺失的命令，並避免非預期的系統存取。

- 如果資料遺失和安全性不是因素，則根據便利性選擇預設的命令。 將最有可能的命令納入為預設值，可在對話方塊支援頻繁或重複性的工作時，改善使用者的工作流程。

避免針對預設命令選擇永久的破壞性動作。 如果有這類命令，請改為選擇更安全的命令做為預設值。

#### <a name="access-keys"></a>便捷鍵
請勿使用 **[確定]、[****取消**] 或 [ 說明] 按鈕的存取金鑰。 根據預設，這些按鈕會對應到快速鍵：

| 按鈕名稱 | 鍵盤快速鍵 |
| --- | --- |
| 確定 | Enter |
| 取消 | Esc |
| 説明 | F1 |

#### <a name="imagery"></a>圖像
在對話方塊中謹慎使用影像。 請勿在對話方塊中使用大型圖示只是用來空間。 只有在將訊息傳達給使用者時（例如警告圖示或狀態動畫）很重要的部分，才使用影像。

### <a name="prioritizing-and-layering"></a><a name="BKMK_PrioritizingAndLayering"></a> 排列優先順序和分層

#### <a name="prioritizing-your-ui"></a>排列 UI 的優先順序
您可能必須將某些 UI 元素帶入 forefront，並放置更高階的行為和選項 (包括) 至對話方塊中的模糊命令。 藉由騰出空間來將常用的功能帶入 forefront，並在顯示對話方塊時，使用文字標籤將它預設顯示在 UI 中。

#### <a name="layering-your-ui"></a>將 UI 分層
如果您已判斷出需要對話，但您想要呈現給使用者的相關功能超出可在簡單對話方塊中顯示的內容，則您需要將 UI 分層。 Visual Studio 使用的最常見分層方法是索引標籤和走廊或儀表板。 在某些情況下，可展開和折迭的區域可能是適當的。 在 Visual Studio 中，通常不建議使用自動調整的 UI。

使用 tab 鍵的控制項將 UI 階層式不同方法有其優點和缺點。 請參閱下列清單，以確定您選擇的是適合您情況的分層技術。

##### <a name="tabbing"></a>定位處理

| 切換機制 | 優點和適當用途 | 缺點和不當使用 |
| --- | --- | --- |
| 索引標籤控制項 | 以邏輯方式將對話頁面分組為相關的集合<br /><br />適用于少於五個 (，或在對話方塊的相關控制項) 頁面上符合一個資料列的索引標籤數目<br /><br />索引標籤標籤必須是簡短的：一或兩個單字，可輕鬆地識別內容<br /><br />一般系統對話樣式<br /><br />範例： **檔案總管 &gt; 專案屬性** | 製作描述性的簡短標籤可能很困難<br /><br />通常不會在單一對話方塊中調整超過五個索引標籤<br /><br />如果您有太多資料列的索引標籤，就不適合 (使用替代的分層技術) <br /><br />不可延伸 |
| 提要欄位導覽 | 可以容納比索引標籤更多類別的簡單切換裝置<br /><br />分類 (沒有階層) 的一般清單<br /><br />可延伸<br /><br />範例： **自訂 ... &gt; 新增命令** | 如果有少於三個群組，則不適合使用水準空間<br /><br />工作可能更適合下拉式清單 |
| 樹狀控制項 | 允許無限制的類別<br /><br />允許分類的群組和/或階層<br /><br />可延伸<br /><br />範例： **工具 &gt; 選項** | 高度嵌套的階層可能會造成過多的水準滾動<br /><br />Visual Studio 具有樹狀檢視的 overabundance |
| 精靈 | 藉由引導使用者完成以工作為基礎的順序步驟來協助完成工作： wizard 代表高階工作，而個別的面板則代表完成整體工作所需的子任務<br /><br />當工作跨越 Ui 界限時很有用，如同使用者需要使用多個編輯器和工具視窗來完成工作一樣<br /><br />當工作需要分支時很有用<br /><br />當工作包含步驟之間的相依性時很有用<br /><br />當有多個類似的工作在一個對話方塊中顯示時，可在單一對話方塊中顯示，以減少不同的相似對話數目 | 不適合任何不需要連續工作流程的工作<br /><br />具有太多步驟的 wizard 可能會使使用者感到不知所措和混淆<br /><br />這些嚮導在本質上有限的螢幕空間 |

##### <a name="hallways-or-dashboards"></a>走廊或儀表板
走廊和儀表板是作為啟動點的對話方塊或面板，可作為其他對話方塊和視窗的起點。 設計完善的「走廊」會立即顯示最常見的選項、命令和設定，讓使用者可以輕鬆地完成一般工作。 如同真實世界的走廊會提供門口來存取其背後的房間，此處較低的 UI 會收集到個別的「房間」 (通常是其他對話) 可從主要走廊存取的相關功能。

或者，在單一集合中提供所有可用功能的 UI，而不是將較不常見的功能重構至不同的位置，只是一個儀表板。

![在 Outlook 中公開其他 UI 的走廊概念](../../extensibility/ux-guidelines/media/0704-08_hallway.png "0704-08_Hallway")<br />在 Outlook 中公開其他 UI 的走廊概念

##### <a name="adaptive-ui"></a>彈性 UI
根據使用量或使用者的自我報告體驗來顯示或隱藏 UI 是另一種呈現必要 UI 的方式，同時隱藏其他部分。 在 Visual Studio 中不建議這麼做，因為決定何時顯示或隱藏 UI 的演算法可能會很難處理，而某些案例的規則一律會發生錯誤。

## <a name="projects"></a><a name="BKMK_Projects"></a> 專案

### <a name="projects-in-the-solution-explorer"></a>方案總管中的專案
大部分的專案會分類為以參考為基礎、以目錄為基礎的或混合。 方案總管中同時支援三種專案類型。 使用專案的使用者體驗的根目錄會在此視窗內進行。 雖然不同的專案節點是參考、目錄或混合模式類型的專案，但有一個常見的互動模式，應該先套用為起點，然後再進入專案特定的使用者模式。

專案應一律：

- 支援新增專案資料夾來組織專案內容的功能

- 維持一致的專案持續性模型

專案也應維持一致的互動模型：

- 移除專案專案

- 儲存檔

- 專案屬性編輯

- 在替代視圖中編輯專案

- 拖放作業

### <a name="drag-and-drop-interaction-model"></a>拖放互動模型
專案通常會將本身分類為參考式 (只要能保存儲存) 中專案專案的參考、以目錄為基礎的 (能夠只保存實際儲存在) 專案階層內的專案專案，或是混合 (可保存參考或實體專案) 。 IDE 會在 **方案總管** 內同時容納這三種類型的專案。

從拖放的觀點來看，下列特性應該適用于 **方案總管** 內的每個專案類型：

- 以 **參考為基礎的專案：** 重點在於專案是在儲存體中的專案參考周圍拖曳。 當以參考為基礎的專案做為移動作業的來源時，應該只從專案中移除專案的參考。 專案實際上不應從硬碟刪除。 當以參考為基礎的專案做為移動 (或複製) 作業的目標時，它應該加入原始來源專案的參考，而不需建立專案的私用複本。

- 以 **目錄為基礎的專案：** 從拖放的觀點來看，專案是在實體專案周圍拖曳，而非參考。 以目錄為基礎的專案做為移動作業的來源時，最後應從硬碟刪除實體專案，以及將它從專案中移除。 以目錄為基礎的專案做為移動 (或複製) 作業的目標時，應該在其目標位置複製來源專案。

- **混合目標專案：** 從拖放的角度來看，這種專案類型的行為取決於拖曳專案的本質 (參考儲存體中的專案或專案本身) 。 參考和實體專案的正確行為詳述于上述。

如果 **方案總管** 中只有一種專案類型，則拖放作業會很簡單。 因為每個專案系統都有能力定義自己的拖放行為，所以會根據 Windows 檔案總管拖放) 行為來 (特定的指導方針，以確保可預測的使用者體驗：

- **方案總管** 中未修改的拖曳作業 (當 Ctrl 或 Shift 鍵都不會被關閉時) 應該會產生移動作業。

- Shift 拖曳作業也應該產生移動作業。

- Ctrl-拖曳作業應該會產生複製操作。

- 參考式和混合專案系統支援將連結 (或參考) 加入至來源專案的概念。 當這些專案是拖放作業的目標時 (當 **Ctrl + Shift** 保持) 時，它應該會產生專案的參考。

並非所有的拖放作業都能在以參考為基礎、以目錄為基礎的專案和混合專案的組合中都合理。 尤其是，假設要在目錄型來源專案和參考型目標專案之間允許移動作業，因為來原始目錄型專案將必須在移動完成時刪除來源專案。 以目標參考為基礎的專案最後會有已刪除專案的參考。

它也會誤導，以允許在這些類型的專案之間進行複製作業，因為目標參考型專案不應建立來源專案的獨立複本。 同樣地，不允許將 Ctrl + Shift 拖曳到以目錄為基礎的目標專案，因為以目錄為基礎的專案無法保存參考。 在不支援拖放作業的情況下，IDE 應該不允許卸載並向使用者顯示) 下指標表格 (所示的無放置游標。

為了適當地執行拖放行為，拖曳的來源專案必須將其本質傳達給目標專案。 例如， (是參考或以目錄為基礎？ ) 這項資訊是由來源提供的剪貼簿格式所表示。 作為拖曳 (或剪貼簿複製作業的來源時) 專案應提供 `CF_VSREFPROJECTITEMS` 或分別提供 `CF_VSSTGPROJECTITEMS` （取決於專案是以參考為基礎或以目錄為基礎）。 這兩種格式都有相同的資料內容，類似于 Windows 格式， `CF_HDROP` 但字串清單（而不是檔案名）是字串的雙 `NULL` 終止清單， `Projref` (從 `IVsSolution::GetProjrefOfItem` 或 `::GetProjrefOfProject` 適當的) 傳回。

當卸載 (或剪貼簿貼上作業的目標) 時，專案應該同時接受 `CF_VSREFPROJECTITEMS` 和 `CF_VSSTGPROJECTITEMS` ，不過，視目標專案和來源專案的本質而定，實際的拖放作業的處理方式會有所不同。 來源專案會根據其是否提供或來宣告其本質 `CF_VSREFPROJECTITEMS` `CF_VSSTGPROJECTITEMS` 。 捨棄的目標瞭解本身的本質，因此有足夠的資訊來決定是否應該執行移動、複製或連結。 使用者也會藉由按 Ctrl、Shift 或 Ctrl 和 Shift 鍵來修改應執行的拖放作業。 放置目標必須適當地指出將在其和方法中預先執行的作業，是很重要的 `DragEnter` `DragOver` 。 **方案總管** 會自動得知來源專案和目標專案是否為相同的專案。

在 Visual Studio 的實例之間拖曳專案專案 (例如，從一個 devenv.exe 的實例拖曳到另一個) ，則是特別不支援的。 **方案總管** 也會直接停用。

使用者應該一律能夠藉由選取專案、將它拖曳到目標位置，以及觀察下列哪一個滑鼠指標在專案卸載之前出現，來決定拖放作業的效果：

| 滑鼠指標 | 命令 | 描述 |
| :---: | --- | --- |
| ![滑鼠「不置放」圖示](../../extensibility/ux-guidelines/media/0706-01_mousenodrop.png "0706-01_MouseNoDrop") | 不捨棄 | 無法將專案放到指定的位置。 |
| ![滑鼠「複製」圖示](../../extensibility/ux-guidelines/media/0706-02_mousecopy.png "0706-02_MouseCopy") | 複製 | 專案將會複製到目標位置。 |
| ![滑鼠「移動」圖示](../../extensibility/ux-guidelines/media/0706-03_mousemove.png "0706-03_MouseMove") | 移動 | 專案將會移至目標位置。 |
| ![滑鼠「加入參考」圖示](../../extensibility/ux-guidelines/media/0706-04_mouseaddref.png "0706-04_MouseAddRef") | 新增參考 | 選取之專案的參考將會新增至目標位置。 |

#### <a name="reference-based-projects"></a>以參考為基礎的專案
 下表摘要說明拖放 (，以及剪下/複製/貼上) 作業，這些作業應該根據針對參考的目標專案所按下的來源專案和輔助按鍵的本質來執行：

| 修飾詞 | 類別 | 來源專案：參考/連結 | 來源專案：實體專案或檔案系統 (`CF_HDROP`)  |
| --- | --- | --- | --- |
| 無修飾元 | 動作 | 移動 | 連結 |
| 無修飾元 | 目標 | 將參考加入至原始專案 | 將參考加入至原始專案 |
| 無修飾元 | 來源 | 刪除原始專案的參考 | 保留原始專案 |
| 無修飾元 | 結果 | `DROPEFFECT_MOVE` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 | `DROPEFFECT_LINK` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 |
| Shift + 拖曳 | 動作 | 移動 | 不捨棄 |
| Shift + 拖曳 | 目標 | 將參考加入至原始專案 | 不捨棄 |
| Shift + 拖曳 | 來源 | 刪除原始專案的參考 | 不捨棄 |
| Shift + 拖曳 | 結果 | `DROPEFFECT_MOVE` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 | 不捨棄 |
| Ctrl + 拖曳 | 動作 | 複製 | 不捨棄 |
| Ctrl + 拖曳 | 目標 | 將參考加入至原始專案 | 不捨棄 |
| Ctrl + 拖曳 | 來源 | 保留原始專案的參考 | 不捨棄 |
| Ctrl + 拖曳 | 結果 | `DROPEFFECT_COPY` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 | 不捨棄 |
| Ctrl + Shift + 拖曳 | 動作 | 連結 | 連結 |
| Ctrl + Shift + 拖曳 | 目標 | 將參考加入至原始專案 | 將參考加入至原始專案 |
| Ctrl + Shift + 拖曳 | 來源 | 保留原始專案的參考 | 保留原始專案 |
| Ctrl + Shift + 拖曳 | 結果 | `DROPEFFECT_LINK` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 | `DROPEFFECT_LINK` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 |
| Ctrl + Shift + 拖曳 | 注意 | 與 Windows 檔案總管中快捷方式的拖放行為相同。 ||
| 剪下/貼上 | 動作 | 移動 | 連結 |
| 剪下/貼上 | 目標 | 將參考加入至原始專案 | 將參考加入至原始專案 |
| 剪下/貼上 | 來源 | 保留原始專案的參考|保留原始專案 |
| 剪下/貼上 | 結果 | 專案會保留在儲存體中的原始位置 | 專案會保留在儲存體中的原始位置 |
| 複製/貼上 | 動作 | 複製 | 連結 |
| 複製/貼上 | 來源 | 將參考加入至原始專案 | 將參考加入至原始專案 |
| 複製/貼上 | 結果 | 保留原始專案的參考 | 保留原始專案 |
| 複製/貼上 | 動作 | 專案會保留在儲存體中的原始位置 | 專案會保留在儲存體中的原始位置 |

#### <a name="directory-based-projects"></a>以目錄為基礎的專案
下表摘要說明拖放 (，以及剪下/複製/貼上) 作業，這些作業應根據來源專案的本質和針對目錄型目標專案所按的輔助按鍵而定：

| 修飾詞 | 類別 | 來源專案：參考/連結 | 來源專案：實體專案或檔案系統 (`CF_HDROP`)  |
|-----------------|----------| - | - |
| 無修飾元 | 動作 | 移動 | 移動 |
| 無修飾元 | 目標 | 將專案複製到目標位置 | 將專案複製到目標位置 |
| 無修飾元 | 來源 | 刪除原始專案的參考 | 刪除原始專案的參考 |
| Shift + 拖曳 | 動作 | 移動 | 移動 |
| Shift + 拖曳 | 目標 | 將專案複製到目標位置 | 將專案複製到目標位置 |
| Shift + 拖曳 | 來源 | 刪除原始專案的參考 | 從原始位置刪除專案 |
| Shift + 拖曳 | 結果 | `DROPEFFECT_MOVE` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 | `DROPEFFECT_MOVE` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 |
| Ctrl + 拖曳 | 動作 | 複製 | 複製 |
| Ctrl + 拖曳 | 目標 | 將專案複製到目標位置 | 將專案複製到目標位置 |
| Ctrl + 拖曳 | 來源 | 保留原始專案的參考 | 保留原始專案的參考 |
| Ctrl + 拖曳 | 結果 | `DROPEFFECT_COPY` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 | `DROPEFFECT_COPY` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 |
| Ctrl + Shift + 拖曳 | | 不捨棄 | 不捨棄 |
| 剪下/貼上 | 動作 | 移動 | 移動 |
| 剪下/貼上 | 目標 | 將專案複製到目標位置 | 將專案複製到目標位置 |
| 剪下/貼上 | 來源 | 刪除原始專案的參考 | 從原始位置刪除專案 |
| 剪下/貼上 | 結果 | 專案會保留在儲存體中的原始位置 | 從儲存體中的原始位置刪除專案 |
| 複製/貼上 | 動作 | 複製 | 複製 |
| 複製/貼上 | 目標 | 將參考加入至原始專案 | 將專案複製到目標位置 |
| 複製/貼上 | 來源 | 保留原始專案 | 保留原始專案 |
| 複製/貼上 | 結果 | 專案會保留在儲存體中的原始位置 | 專案會保留在原始位置的儲存體中 |

#### <a name="mixed-target-projects"></a>混合目標專案
下表摘要說明拖放 (以及剪下/複製/貼上) 作業，這些作業應該根據針對混合目標專案所按下的來源專案和輔助按鍵的本質來執行：

| 修飾詞 | 類別 | 來源專案：參考/連結 | 來源專案：實體專案或檔案系統 (`CF_HDROP`)  |
| --- | --- | --- | --- |
| 無修飾元 | 動作 | 移動 | 移動 |
| 無修飾元 | 目標 | 將參考加入至原始專案 | 將專案複製到目標位置 |
| 無修飾元 | 來源 | 刪除原始專案的參考 | 刪除原始專案的參考 |
| 無修飾元 | 結果 | `DROPEFFECT_ MOVE` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 | `DROPEFFECT_ MOVE` 從儲存體中的原始位置傳回做為動作 `::Drop` ，而專案已刪除 |
| Shift + 拖曳 | 動作 | 移動 | 移動 |
| Shift + 拖曳 | 目標 | 將參考加入至原始專案 | 將專案複製到目標位置 |
| Shift + 拖曳 | 來源 | 刪除原始專案的參考 | 從原始位置刪除專案 |
| Shift + 拖曳 | 結果 | `DROPEFFECT_ MOVE` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 | `DROPEFFECT_ MOVE` 從儲存體中的原始位置傳回做為動作 `::Drop` ，而專案已刪除 |
| Ctrl + 拖曳 | 動作 | 複製 | 複製 |
| Ctrl + 拖曳 | 目標 | 將參考加入至原始專案 | 將專案複製到目標位置 |
| Ctrl + 拖曳 | 來源 | 保留原始專案的參考 | 保留原始專案 |
| Ctrl + 拖曳 | 結果 | `DROPEFFECT_ COPY` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 | `DROPEFFECT_ COPY` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 |
| Ctrl + Shift + 拖曳 | 動作 | 連結 | 連結 |
| Ctrl + Shift + 拖曳 | 目標 | 將參考加入至原始專案 | 將參考新增至原始來源專案 |
| Ctrl + Shift + 拖曳 | 來源 | 保留原始專案的參考 | 保留原始專案 |
| Ctrl + Shift + 拖曳 | 結果 | `DROPEFFECT_ LINK` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 | `DROPEFFECT_ LINK` 會傳回做為動作 `::Drop` ，而專案會保留在儲存體中的原始位置 |
| 剪下/貼上 | 動作 | 移動 | 移動 |
| 剪下/貼上 | 目標 | 將專案複製到目標位置 | 將專案複製到目標位置 |
| 剪下/貼上 | 來源 | 刪除原始專案的參考 | 從原始位置刪除專案 |
| 剪下/貼上 | 結果 | 專案會保留在儲存體中的原始位置 | 從儲存體中的原始位置刪除專案 |
| 複製/貼上 | 動作 | 複製 | 複製 |
| 複製/貼上 | 目標 | 將參考加入至原始專案 | 將專案複製到目標位置 |
| 複製/貼上 | 來源 | 保留原始專案 | 保留原始專案 |
| 複製/貼上 | 結果 | 專案會保留在儲存體中的原始位置 | 專案會保留在儲存體中的原始位置 |

在 **方案總管** 中執行拖曳時，應考慮這些詳細資料：

- 設計多重選取案例。

- 檔案名 (完整路徑) 在目標專案中必須是唯一的，否則不應允許放置。

- 資料夾名稱在卸載的層級上必須是唯一 (不區分大小寫的) 。

- 在拖曳時開啟或關閉的檔案之間有一些行為差異 (未在上述案例中提及) 。

- 最上層檔案的行為與資料夾中的檔案稍有不同。

另一個要注意的問題，就是如何處理具有開啟的設計工具或編輯器之專案上的移動作業。 預期的行為如下 (這適用于所有專案類型) ：

1. 如果開啟的編輯器/設計師沒有任何未儲存的變更，則 [編輯器]/[設計工具] 視窗應該以無訊息方式關閉。

2. 如果開啟的編輯器/設計師有未儲存的變更，則拖曳的來源應該等候放置發生，然後在關閉視窗之前要求使用者將未認可的變更儲存在開啟的檔中，並出現類似下列的提示：

    ```
    ==========================================================
         One or more open documents have unsaved changes.
    Do you want to save uncommitted changes before proceeding?
                      [Yes]  [No]  [Cancel]
    ==========================================================
    ```

如此一來，使用者就有機會儲存進行中的工作，然後再將其複製到目標。 已加入新的方法 `IVsHierarchyDropDataSource2::OnBeforeDropNotify` 來啟用此處理。

然後目標會複製專案在儲存體中的狀態 (不包括編輯器中未儲存的變更（如果使用者選擇 [ **否**) ]）。 當目標完成其複製 (在) 中 `IVsHierarchyDropDataSource::Drop` ，來源會有機會完成移動作業的刪除部分 (在 `IVsHierarchyDropDataSource::OnDropNotify`) 中。

任何具有未儲存之變更的編輯器都應該保持開啟狀態。 針對那些具有未儲存之變更的檔，這表示將會執行移動作業的複製部分，但刪除部分將會中止。 當使用者選擇 [ **否**] 時，在多個選取的案例中，不應該關閉或移除具有未儲存之變更的檔，但不應該關閉和移除沒有未儲存之變更的檔。
