---
title: 視覺工作室的應用模式 |微軟文件
ms.date: 04/26/2017
ms.topic: conceptual
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
author: acangialosi
ms.author: anthc
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: 036c95951fe3dc9e65a0f3338f75ae9867d721c3
ms.sourcegitcommit: 16a4a5da4a4fd795b46a0869ca2152f2d36e6db2
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/06/2020
ms.locfileid: "80698588"
---
# <a name="application-patterns-for-visual-studio"></a>適用於 Visual Studio 的應用程式模式
## <a name="window-interactions"></a><a name="BKMK_WindowInteractions"></a>窗互

### <a name="overview"></a>概觀
Visual Studio 中使用的兩種主要視窗類型是文檔編輯器和工具視窗。 很少(但可能)是大型無模式對話方塊。 儘管這些在 shell 中都是無模式的,但他們的模式卻截然不同。 本節介紹文檔視窗、工具視窗和無模式對話框之間的區別。 模式對話框模式在[對話框](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs)中介紹。

### <a name="comparing-window-usage-patterns"></a>比較視窗使用模式
**文件視窗**幾乎總是顯示在文檔中。 這為文件編輯器提供了一個「中心階段」來安排周圍的補充工具視窗。

**工具視窗**通常顯示為在 IDE 邊緣摺疊的單獨較小視窗。 這可以可見、隱藏或自動隱藏。 但是,有時工具視窗通過在文檔中取消選中**視窗/停靠**屬性顯示在文檔中。 這會導致更多的房地產,但也一個共同的設計決策:當嘗試集成到 Visual Studio 時,您必須決定您的功能是顯示工具視窗還是文檔視窗。

在視覺工作室中不鼓勵**無模式對話方塊**。 根據定義,大多數無模式對話框都是浮動工具窗口,應該以這種方式實現。 如果停靠在外殼側面的正常工具視窗的大小過於限制,則允許進行無模式對話方塊。 如果使用者可能會將對話框移動到輔助監視器,則也允許它們。

仔細考慮您需要哪種容器類型。 下表中提供了 UI 設計的常見使用模式注意事項。

||文件視窗|工具視窗|沒有模式對話框|
|-|---------------------|-----------------|---------------------|
| **位置** | 始終放置在文檔中,並且不停靠在IDE的邊緣周圍。 它可以"拉下",以便它與主殼分開浮動。 | 通常,選項卡停靠在IDE的邊緣,但可以自定義為浮動、自動隱藏(未固定)或停靠在文檔中。|與 IDE 分開的大型浮動視窗。 |
| **提交模型** | *延遲提交*<br /><br /> 為了將資料儲存在文件中,使用者必須發出 **「&gt;檔案儲存**、**另存為**」或 **「全部儲存」** 命令。 文件視窗中的數據的概念是"已刪除",然後提交到其中一個保存命令。 關閉文件視窗時,所有內容都將保存到磁碟或丟失。 | *立即提交*<br /><br /> 沒有保存模型。 對於幫助編輯檔的檢查器工具視窗,必須在活動編輯器或設計器中打開該檔,並且編輯器或設計器擁有保存。 | *延遲或立即提交*<br /><br /> 通常,大型無模式對話方塊需要操作來提交更改,並允許執行"取消"操作,該操作回滾在對話方塊會話中所做的任何更改。  這將無模式對話框與該工具視窗中的工具視窗區分開來,該工具視窗中始終具有即時提交模型。 |
| **知名度** | *開啟/建立(檔案)與關閉*<br /><br /> 開啟文件視窗是通過打開現有文檔或使用範本創建新文件來完成的。 沒有「打開\<特定編輯器>」命令。 | *隱藏與顯示*<br /><br /> 可以隱藏或顯示單實例工具視窗。 無論在檢視中還是隱藏中,工具視窗中的內容和狀態都保持不變。 可以關閉和隱藏多實例工具視窗。 關閉多實例工具視窗時,將丟棄工具視窗中的內容和狀態。 | *從命令啟動*<br /><br /> 對話框從基於任務的命令啟動。 |
| **實體** | *多實體*<br /><br /> 多個編輯器可以同時打開並編輯不同的檔案,而某些編輯器還允許在多個編輯器中打開同一檔(使用 **"&gt;視窗新視窗**"命令)。<br /><br /> 單個編輯器可能同時編輯一個或多個檔(專案設計器)。 | *單實例或多實體*<br /><br /> 內容更改以反映上下文(如屬性瀏覽器中)或將焦點/上下文推送到其他視窗(任務列表、解決方案資源管理員)。<br /><br /> 單實例和多實例工具視窗都應與活動文檔視窗關聯,除非有令人信服的理由不這樣做。 | *單實例* |
| **範例** | **文字編輯器**,如代碼編輯器<br /><br /> **設計曲面**,如表單設計器或建模曲面<br /><br /> **控制項佈局來顯示對話框**,如清單設計器 | **解決方案資源管理員**提供解決方案中包含的解決方案和專案<br /><br /> **伺服器資源管理員**提供使用者選擇在視窗中打開的伺服器和數據連接的分層檢視。 從資料庫層次結構(如查詢)打開物件將打開文檔視窗,並允許使用者編輯查詢。<br /><br /> **屬性瀏覽器**顯示在文檔視窗或其他工具視窗中選擇的物件的屬性。 這些屬性在分層網格檢視或類似對話的複雜控制項中顯示,並允許使用者設置這些屬性的值。 | |

## <a name="tool-windows"></a><a name="BKMK_ToolWindows"></a>工具視窗

### <a name="overview"></a>概觀
工具視窗支援在文件視窗中發生的使用者工作。 它們可用於顯示表示 Visual Studio 提供並可以操作的基本根物件的層次結構。

在 IDE 中考慮新工具視窗時,作者應:

- 使用適合任務的現有工具視窗,而不是創建具有類似功能的新工具視窗。 僅當新工具視窗提供無法整合到類似視窗中的顯著不同的「工具」或功能,或者透過現有視窗轉換為旋轉中心,才應創建新工具視窗。

- 如果需要,請使用工具視窗頂部的標準命令列。

- 與控制項簡報簡報和鍵盤導航的其他工具視窗中已有的模式保持一致。

- 與其他工具視窗中的控制演示文稿保持一致。

- 盡可能使特定於文檔的工具視窗自動可見,以便它們僅在啟動父文檔時才顯示。

- 確保其視窗內容可通過鍵盤(支援箭頭鍵)導航。

#### <a name="tool-window-states"></a>工具視窗狀態
Visual Studio 工具視窗具有不同的狀態,其中一些狀態是使用者啟動的(如自動隱藏功能)。 其他狀態(如自動可見狀態)允許工具視窗顯示在正確的上下文中,並在不需要時隱藏。 共有五個工具視窗狀態。

- **停靠/固定**工具視窗可以附加到文件區域的四個邊中的任何一個。 圖釘圖示將顯示在工具視窗標題列中。 工具視窗可以沿殼體和其他工具視窗的邊緣水準或垂直停靠,也可以與選項卡連結。

- **自動隱藏**的工具視窗將取消固定。 視窗可以滑出視線,在文件區域的邊緣留下一個選項卡(帶有工具視窗的名稱及其圖示)。 當使用者懸停在選項卡上時,工具視窗會滑出。

- 當另一塊 UI(如編輯器)啟動或獲得焦點時,自動**可見**工具視窗會自動顯示。

- **浮動**工具視窗懸停在 IDE 外部。 這對於多監視器配置很有用。

- **選項卡式文件**工具視窗可以停靠在文檔中。 這對於大型工具視窗(如物件瀏覽器)非常有用,這些視窗需要比停靠到框架邊緣允許的更多空間。

![Visual Studio 中的工具視窗狀態](../../extensibility/ux-guidelines/media/0702-01_toolwindowstates.png "0702-01_ToolWindowStates")<br />Visual Studio 中的工具視窗狀態

#### <a name="single-instance-and-multi-instance"></a>單實例和多實體
工具視窗是單實例或多實例。 某些單實例工具視窗可能與活動文件視窗相關聯,而多實例工具視窗可能未關聯。 多實例工具視窗通過建立視窗的新實例來回應 **「&gt;視窗新視窗」** 命令。 下圖展示了當視窗實體處執行活動狀態時啟用「新的視窗」命令的工具視窗:

![當視窗執行樣式時開啟「新視窗」指令的工具視窗](../../extensibility/ux-guidelines/media/0702-02_toolwindowenablingcommand.png "0702-02_ToolWindowEnablingCommand")<br />當視窗執行樣式時開啟「新視窗」指令的工具視窗

可以隱藏或顯示單實例工具視窗,而多實例工具視窗可以關閉和隱藏。 所有工具視窗都可以停靠、選項卡連結、浮動或設置為多文檔介面 (MDI) 子視窗(類似於文檔視窗)。 所有工具視窗都應回應「視窗」選單中的相應視窗管理命令:

![視覺化工作室視窗選單中的視窗管理命令](../../extensibility/ux-guidelines/media/0702-03_windowmanagementcontrols.png "0702-03_WindowManagementControls")<br />視覺化工作室視窗選單中的視窗管理命令

#### <a name="document-specific-tool-windows"></a>特定於文件的工具視窗
某些工具視窗旨在根據給定的文件類型進行更改。 這些窗口不斷更新以反映適用於 IDE 中活動文件視窗的功能。

其內容更改以反映所選編輯器的工具視窗的範例包括「工具箱」和「文檔大綱」。 當編輯器具有不向視窗提供上下文的焦點時,這些視窗將顯示水印。

#### <a name="navigable-list-tool-windows"></a>導覽清單工具視窗
某些工具視窗顯示使用者可以與之互動的可導航項的清單。 在這種類型的視窗中,應始終對清單中的當前項進行反饋,即使視窗處於非活動狀態也是如此。 清單應回應**GoToNextLocation**和**GoTotovlocation 命令**,同時更改視窗中目前選取的項目

可導航列表工具視窗的範例包括"解決方案資源管理員"和"尋找結果"視窗。

### <a name="tool-window-types"></a>工具視窗類型

#### <a name="common-tool-windows-and-their-functions"></a>常用工具視窗及功能

**階層工具視窗**

| 工具視窗 | 函式 |
| --- | --- |
| 方案總管 | 顯示項目、雜項檔和解決方案項中包含的文檔清單的分層樹。 專案中項的顯示由擁有項目類型的包定義(例如,基於引用、基於目錄或混合模式的類型)。 |
| 類別檢視 | 工作文檔集中的類和各種元素的分層樹,獨立於檔本身。 |
| Server Explorer | 顯示解決方案中的所有伺服器和數據連接的分層樹。 |
| 文件大綱 | 活動文檔的層次結構。 |

**格線工具視窗**

| 工具視窗 | 函式 |
| --- | --- |
| 屬性 | 顯示選取物件的屬性清單以及用於編輯這些屬性的值選取器的網格。 |
| 工作清單 | 允許使用者創建/編輯/刪除任務和註釋的網格。 |

**內容工具視窗**

| 工具視窗 | 函式 |
| --- | --- |
| 説明 | 一個視窗,允許使用者訪問各種方法來獲取説明,從「我如何? 視頻到MSDN論壇。 |
| 動態說明 | 一個工具視窗,用於顯示説明適用於當前選擇的主題的連結。 |
| 物件瀏覽器 | 兩列框架集,在左窗格中包含分層物件元件的清單,在右列中包含物件的屬性和方法。 |

**對話框工具視窗**

| 工具視窗 | 函式 |
| --- | --- |
| Find | 允許使用者在解決方案中的各種檔中尋找或尋找和替換的對話框。 |
| 進階尋找 | 允許使用者在解決方案中的各種檔中尋找或尋找和替換的對話框。 |

**其他工具視窗**

::: moniker range="vs-2017"

| 工具視窗 | 函式 |
| --- | --- |
| 工具箱 | 用於儲存將拖放到設計表面的元素的工具視窗,為所有設計器提供一致的拖動源。 |
| 起始頁 | 使用者訪問 Visual Studio 的門戶,可以造訪開發人員新聞、Visual Studio 説明和最近專案的源。 使用者還可以透過將 StartPage.xaml 檔案從「\"常見 7_IDE_StartPages Visual Studio 程式檔目錄複製到 Visual Studio 文件目錄中的 StartPages」 資料夾,然後手動編輯 XAML 或在 Visual Studio 或其他代碼編輯器中打開它來創建自訂起始頁。 |

::: moniker-end

::: moniker range=">=vs-2019"

| 工具視窗 | 函式 |
| --- | --- |
| 工具箱 | 用於儲存將拖放到設計表面的元素的工具視窗,為所有設計器提供一致的拖動源。 |

::: moniker-end

**除錯器工具視窗**

| 工具視窗 | 函式 |
| --- | --- |
| 自動 ||
| 立即 ||
| Output | 只要您要聲明文本事件或狀態,即可使用輸出視窗。 |
| 記憶體 ||
| 中斷點 ||
| 執行中 ||
| 文件 ||
| 呼叫堆疊 ||
| 本機 ||
| 手錶 ||
| 反組譯碼 ||
| 暫存器 ||
| Threads ||

## <a name="document-editor-conventions"></a><a name="BKMK_DocumentEditorConventions"></a>文件編輯器約定

### <a name="document-interactions"></a>文件互動
"文檔井"是IDE中最大的空間,使用者通常集中注意力以完成其任務,並由補充工具視窗協助。 文件編輯器表示使用者在 Visual Studio 中打開和保存的基本工作單元。 它們保留了與解決方案資源管理器或其他活動層次結構窗口相關聯的強大選擇感。 用戶應該能夠指向其中一個層次結構視窗,並知道文檔的包含位置及其與解決方案、專案或 Visual Studio 包提供的另一個根物件的關係。

文檔編輯需要一致的用戶體驗。 要允許使用者專注於手頭的任務,而不是視窗管理和查找命令,請選擇最適合編輯該文檔類型的使用者任務的文檔視圖策略。

#### <a name="common-interactions-for-the-document-well"></a>文件的常見互動

- 在常見的 **「新檔和****打開檔**」體驗中保持一致的交互模型。

- 打開文件視窗時,更新相關視窗和功能表中的相關功能。

- 選單指令被適當地整合到常見的選單中,如 **「編輯**」、「**格式**」和「**檢視」** 選單。 如果提供大量的專用命令可用,則可以創建新功能表。 僅當文檔具有焦點時,此新菜單才應可見。

- 嵌入工具列可以放置在編輯器的頂部。 這比在編輯器外部顯示單獨的工具列更可取。

- 始終在解決方案資源管理器或類似的活動層次結構視窗中維護選擇。

- 雙擊解決方案資源管理員中的文件應執行與**Open**相同的操作。

- 如果在文件類型上可以使用多個編輯器,則使用者應該能夠透過右鍵單擊檔案並從快捷選單中選擇 **「打開可用**」對話框,使用 **「打開」** 對話框覆蓋或重置給定文件類型的預設操作。

- 不要在文檔中構建嚮導。

### <a name="user-expectations-for-specific-document-types"></a>使用者對特定文件類型的期望
有幾種不同的基本類型的文檔編輯器,每個類型都有一組與相同類型的其他交互一致。

- **基於文字的編輯器:** 程式碼編輯器、記錄檔

- **設計表面:** WPF 窗體設計器、Windows 表單

- **對話樣式編輯器:** 清單設計器,專案屬性

- **模型設計器:** 工作流設計器、程式碼映射、架構結構圖、進度

還有幾種非編輯器類型很好地使用文檔。 雖然它們不自行編輯文檔,但它們確實需要遵循文檔視窗的標準交互。

- **報告:** IntelliTrace 報告、Hyper-V 報告、探查器報告

- **儀表板:** 診斷中心

#### <a name="text-based-editors"></a>基於文字的編輯器

- 文件參與預覽選項卡模型,允許在不打開文檔的情況下預覽文檔。

- 文件的結構可以在配套工具視窗中表示,例如文檔大綱。

- IntelliSense(如果適用)將與其他代碼編輯器保持一致。

- 彈出視窗或輔助 UI 遵循現有類似 UI(如 CodeLens)的類似樣式和模式。

- 有關文件狀態的消息將在文檔頂部的資訊列控制項或狀態列中顯示。

- 用戶必須能夠使用**工具>選項**頁面、共用的字體和顏色頁面或特定於編輯器的頁面自定義字體和顏色的外觀。

#### <a name="design-surfaces"></a>設計表面

- 空設計器應表面有一個浮浮水印,指示如何開始。

- 檢視切換機制將遵循現有模式,例如按兩下以打開代碼編輯器,或在文檔視窗中允許與兩個窗格互動的選項卡。

- 除非需要高度特定的工具視窗,否則應通過工具箱向設計圖面添加元素。

- 曲面上的專案將遵循一致的選擇模型。

- 嵌入工具列僅包含特定於文檔的命令,而不是常見的命令,如 **「儲存**」。

#### <a name="dialog-style-editors"></a>對話樣式編輯器

- 控件佈局應遵循正常的對話框布局約定。

- 編輯器中的選項卡不應與文檔選項卡的外觀匹配,它們應與兩個允許的內部選項卡樣式之一匹配。

- 用戶必須能夠僅使用鍵盤與控制件進行互動;通過啟動編輯器並通過控制項進行 Tab 鍵,或者使用標準助記符。

- 設計器應使用通用的"保存"模型。 不應在曲面上放置整體"保存"或"提交"按鈕,儘管其他按鈕可能合適。

#### <a name="model-designers"></a>模型設計師

- 空設計器應表面有一個浮浮水印,指示如何開始。

- 應通過工具箱向設計圖面添加元素。

- 曲面上的專案將遵循一致的選擇模型。

- 嵌入工具列僅包含特定於文檔的命令,而不是常見的命令,如 **「儲存**」。

- 圖例可能出現在曲面上,指示性標記或浮浮浮水印。

- 用戶必須能夠使用**工具>選項**頁面、共用的字體和顏色頁面或特定於編輯器的頁面自定義字體/顏色的外觀。

#### <a name="reports"></a>報表

- 報表通常僅供參考,並且不參與"保存"模型。 但是,它們可能包括交互,例如指向其他相關信息的連結或展開和摺疊的部分。

- 表面上的大多數命令應該是超連結,而不是按鈕。

- 佈局應包括標題並遵循標準報表佈局準則。

#### <a name="dashboards"></a>儀表板

- 儀錶板本身沒有交互模型,而是作為提供各種其他工具的一種手段。

- 他們不參與"保存"模型。

- 用戶必須能夠僅使用鍵盤與控制件進行互動,既透過啟動編輯器並透過控制項進行選項卡,要麼使用標準助記符。

## <a name="dialogs"></a><a name="BKMK_Dialogs"></a>對話框

### <a name="introduction"></a>簡介
可視化工作室中的對話框通常應支援使用者工作的一個獨立單元,然後被駁回。

如果您確定需要一個對話框,則有三個選項,按首選項順序排列:

1. 將您的功能整合到 Visual Studio 中的共享對話方塊之一中。

2. 使用現有類似對話框中找到的模式創建自己的對話方塊。

3. 按照交互和佈局指南創建新對話方塊。

本節介紹如何在 Visual Studio 工作流中選擇正確的對話框模式以及對話框設計的通用約定。

### <a name="themes"></a>主題
可視化工作室中的對話框遵循以下兩種基本樣式之一:

#### <a name="standard-unthemed"></a>標準(無主題)
大多數對話框是標準實用程序對話框,應取消主題。 不要重新範本通用控制項或嘗試創建樣式化的"現代"按鈕或控制項。 控制項與鑲邊外觀遵循[對話框的標準 Windows 桌面互動準則](/windows/desktop/uxguide/win-dialog-box)。

#### <a name="themed"></a>主題
專業"簽名"對話框可能是主題對話方塊。 主題對話框具有獨特的外觀,其中也有一些與樣式關聯的特殊交互模式。 僅當對話框滿足以下要求時,它才主題:

- 該對話框是一種常見體驗,經常或由許多使用者(例如"**新項目**"對話框)經常看到和使用。

- 該對話框包含突出的產品品牌元素(例如,"**帳戶設置"** 對話方塊)。

- 該對話框顯示為包含其他主題對話框(例如"**添加已連接服務"** 對話方塊)的大流的組成部分。

- 該對話框是體驗的重要組成部分,在推廣或區分產品版本方面發揮著戰略作用。

創建主題對話方塊時,請使用適當的環境顏色並遵循正確的佈局和互動模式。 (請參閱[可視化工作室的佈局](../../extensibility/ux-guidelines/layout-for-visual-studio.md)。

### <a name="dialog-design"></a>對話框設計
精心設計的對話框考慮了以下元素:

- 受支援的使用者工作

- 對話框文字樣式、語言和術語

- 控制項選擇與 UI 約定

- 視覺化佈局規範並控制對齊

- 存取鍵盤

#### <a name="content-organization"></a>內容組織
請考慮這些基本型態的對話框之間的差異:

- [簡單對話框](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs)在單個模式視窗中顯示控制項。 簡報文稿可能包括複雜控制模式的變化,包括欄位選取器或圖示列。

- [分層對話框](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs)用於充分利用螢幕空間,當一個 UI 部分包含多個控制元件元件時。 對話框的分組通過選項卡控制件、導航列表控制件或按鈕進行「分層」,以便使用者可以選擇在任何給定時刻要查看的分組。

- [嚮導](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards)可用於指導使用者完成任務的邏輯步驟序列。 順序面板中提供了一系列選擇,有時引入不同的工作流("分支"),具體取決於上一個面板中所做的選擇。

#### <a name="simple-dialogs"></a><a name="BKMK_SimpleDialogs"></a>簡單對話框
簡單對話框是在單個模式視窗中表示控件。 此展示文稿可能包括複雜控制模式(如欄位選取器)的變體。 對於簡單對話框,請遵循標準常規佈局以及複雜控制項分組所需的任何特定佈局。

![>创建强名称键是可视化工作室中简单对话框的示例。](../../extensibility/ux-guidelines/media/0704-01_createstrongnamekey.png "0704-01_CreateStrongNameKey")<br />創建強名稱鍵是可視化工作室中簡單對話框的示例。

#### <a name="layered-dialogs"></a><a name="BKMK_LayeredDialogs"></a>階層對話框
分層對話框包括選項卡、儀錶板和嵌入的樹。 當一個 UI 中提供了多個控制元件元件時,它們用於最大化房地產。 分組是分層的,以便用戶可以選擇在任意時間要查看的分組。

在最直接的情況下,分組之間切換的機制是選項卡控件。 有多種替代方法可供選擇。 有關如何選擇最合適的樣式,請參閱優先順序和分層。

**「&gt;工具」 選項「** 對話框」 是使用嵌入樹分層對話框的範例:

![工具>選項是可視化工作室中分層對話框的範例。](../../extensibility/ux-guidelines/media/0704-02_toolsoptions.png "0704-02_ToolsOptions")<br />工具>選項是可視化工作室中分層對話框的範例。

#### <a name="wizards"></a><a name="BKMK_Wizards"></a>嚮導
嚮導可用於指導使用者完成任務時的邏輯步驟序列。 順序面板中提供了一系列選項,用戶必須繼續執行每個步驟,然後才能繼續執行下一步。 一旦有足夠的預設值可用,將啟用 **"完成"** 按鈕。

 模式精靈用於:

- 包含分支,根據使用者選擇提供不同的路徑

- 包含步驟之間的依賴項,其中後續步驟依賴於上一步中的用戶輸入

- 足夠複雜,應使用 UI 來解釋每個步驟中提供的選項和可能的結果

- 是事務性的,要求在提交任何更改之前完成一組步驟

### <a name="common-conventions"></a>共同公約
要實現對話方塊的最佳設計和功能,請遵循這些約定,包括對話方塊大小、位置、標準、控制配置和對齊、UI 文本、標題列、控制按鈕和訪問鍵。

有關特定於佈局的指南,請參閱[可視化工作室的佈局](../../extensibility/ux-guidelines/layout-for-visual-studio.md)。

#### <a name="size"></a>大小
對話框應適合至少 1024x768 螢幕解析度,初始對話方塊大小不應超過 900x700 圖元。 對話框可以調整大小,但這不是要求。

有兩個可調整大小的對話框的建議:

1. 最小大小是為對話方塊定義的,該對話方塊將針對控制項集進行優化,而不進行剪切,並進行調整以適應合理的當地語系化增長。

2. 使用者縮放的大小在會話和會話中仍然存在。 例如,如果使用者將對話框縮放為 150%,則隨後啟動對話框將顯示為 150%。

#### <a name="position"></a>位置
對話必須在首次啟動時顯示在 IDE 中居中。 不需要持久化非可調整大小的對話框的最後位置,因此它們將顯示在後續啟動的中心。

對於可調整大小的對話框,應在後續啟動時保留大小。 對於可調整大小的模態對話框,無需保留該位置。 在 IDE 中顯示它們居中可防止當使用者的顯示配置發生更改時,對話方塊在不可預測或不可用的位置顯示的可能性。

對於可以重新置放的無模式對話方塊,應在後續啟動時維護使用者的位置,因為該對話框可能經常用作較大工作流的組成部分。

當對話框必須生成其他對話方塊時,最上面的對話方塊應從父對話框向右和向下級聯,以便使用者清楚顯示它們已導航到新位置。

#### <a name="modality"></a>形態
模態意味著使用者在繼續之前必須完成或取消對話方塊。 由於模態對話方塊阻止使用者與環境的其他部分互動,因此功能的任務流應盡可能謹慎地使用它們。 當需要模式操作時,Visual Studio 具有許多共用對話方塊,您可以將功能集成到其中。 如果必須創建新對話框,請遵循具有類似功能的現有對話框的互動模式。

當使用者需要同時執行兩個活動(如在編寫新代碼時**尋找**和**替換**)時,對話框應不模式,以便用戶可以輕鬆地在它們之間切換。 Visual Studio 通常使用工具視窗執行此類支援編輯器的連結任務。

#### <a name="control-configuration"></a>控制設定
與在 Visual Studio 中完成相同操作的現有控制配置保持一致。

#### <a name="title-bars"></a>標題列

- 標題列中的文本必須反映啟動該命令的命令的名稱。

- 對話框標題列中不應使用任何圖示。 在系統需要的情況下,請使用 Visual Studio 徽標。

- 對話框不應具有最小化或最大化按鈕。

- 標題列中的説明按鈕已被棄用。 不要將它們添加到新對話框中。 當它們確實存在時,它們應啟動一個與任務在概念上相關的幫助主題。

  ![可視化工作室對話框中標題列的指南規範](../../extensibility/ux-guidelines/media/0704-03_titlebarspecs.png "0704-03_TitleBarSpecs")<br />可視化工作室對話框中標題列的指南規範

#### <a name="control-buttons"></a>控制按鈕
通常,「**確定**」、「**取消**」和「**説明**」按鈕應水準排列在對話框的右下角。 如果對話框底部有幾個其他按鈕,這些按鈕會對控件按鈕造成視覺混淆,則允許備用垂直堆疊。

![視覺化工作室對話框中控制按鈕的可接受設定](../../extensibility/ux-guidelines/media/0704-04_controlbuttonconfig.png "0704-04_ControlButtonConfig")<br />視覺化工作室對話框中控制按鈕的可接受設定

該對話框必須包含預設控制項按鈕。 要確定用作預設值的最佳命令,請從以下選項中進行選擇(按優先順序順序列出):

- 選擇最安全、最安全的命令作為預設值。 這意味著選擇最有可能防止數據丟失和避免意外系統訪問的命令。

- 如果數據丟失和安全性不是因素,則根據便利性選擇預設命令。 當對話框支援頻繁或重複的任務時,將最有可能的命令作為預設值將改進使用者的工作流。

避免為默認命令選擇永久破壞性操作。 如果存在此類命令,請選擇更安全的命令作為預設值。

#### <a name="access-keys"></a>存取金鑰
請勿將存取鍵用於 **「確定**」、「**取消**」或 **「説明**」按鈕。 預設情況下,這些按鈕對應到捷徑:

| 按鈕名稱 | 鍵盤快速鍵 |
| --- | --- |
| [確定] | Enter |
| 取消 | Esc |
| 説明 | F1 |

#### <a name="imagery"></a>影像
在對話框中謹慎使用圖像。 不要在對話框中使用大圖示只是為了佔用空間。 僅當圖像是向使用者傳達消息的重要部分(如警告圖示或狀態動畫)時,才使用圖像。

### <a name="prioritizing-and-layering"></a><a name="BKMK_PrioritizingAndLayering"></a>優先權與分層

#### <a name="prioritizing-your-ui"></a>確定 UI 的優先權
可能需要將某些 UI 元素放在首位,並將更高級的行為和選項(包括模糊的命令)放入對話框中。 通過為其騰出空間,並在顯示對話框時,在 UI 中預設使用帶有文本標籤的 UI 中使其可見,從而將常用功能置於最前沿。

#### <a name="layering-your-ui"></a>階層介面
如果確定需要對話方塊,但要向使用者顯示的相關功能超出了可在簡單對話框中顯示的功能,則需要對 UI 進行分層。 Visual Studio 最常用的分層方法是選項卡、走廊或儀錶板。 在某些情況下,可以擴展和摺疊的區域可能合適。 視覺工作室通常不建議使用自適應 UI。

通過類似選項卡的控件對 UI 進行分層的不同方法有優點和缺點。 檢視下面的清單,以確保您選擇適合您的情況的分層技術。

##### <a name="tabbing"></a>定位處理

| 開關機構 | 優勢和適當使用 | 缺點和不當使用 |
| --- | --- | --- |
| 索引標籤控制項 | 邏輯上將對話框頁分組到相關集中<br /><br />對於對話框中相關控制項的五個(或適合在對話框中一行中的選項卡數)少於五個(或選項卡數)非常有用<br /><br />選項卡標籤必須簡短:一個或兩個單詞,可以輕鬆地識別內容<br /><br />通用系統對話框樣式<br /><br />範例:**檔案資源管理&gt;員屬性** | 製作描述性短標籤可能很困難<br /><br />通常不會在一對話框中縮放超過五個選項卡<br /><br />如果一行的選項卡太多(使用替代分層技術),則不合適<br /><br />無法延伸 |
| 邊欄導航 | 簡單的切換裝置,可以容納比選項卡更多的類別<br /><br />類別的平面清單(無層次結構)<br /><br />可延伸<br /><br />範例:**自訂...新增&gt;指令** | 如果水準空間少於三組,則不能很好地使用水平空間<br /><br />工作可能更適合下拉 |
| 樹狀控制項 | 允許無限類別<br /><br />允許對類別進行群組和/或層次結構<br /><br />可延伸<br /><br />範例:**&gt;工具選項** | 嚴重嵌套層次結構可能會導致過度的水準滾動<br /><br />視覺工作室擁有過多的樹景 |
| 精靈 | 通過指導使用者完成基於任務的順序步驟,説明完成任務:嚮導表示高級任務,各個面板表示完成整個任務所需的子任務<br /><br />當工作跨越 Ui 邊界時很有用,例如使用者必須使用多個編輯器和工具視窗來完成工作<br /><br />當工作需要分支時有用<br /><br />當任務包含步驟之間的依賴項時很有用<br /><br />當一個對話框中可以顯示多個具有一個決策分叉的類似任務以減少不同類似對話框的數量時非常有用 | 不適合不需要順序工作流的任何任務<br /><br />用戶可以因嚮導過多而不知所措和困惑<br /><br />巫師有固有的有限的螢幕房地產 |

##### <a name="hallways-or-dashboards"></a>走廊或儀表板
"導航"和"儀錶板"是用作其他對話框和視窗的啟動點的對話框或面板。 精心設計的"hallway"立即只顯示最常見的選項、命令和設置,使用戶能夠輕鬆完成常見任務。 與實際走廊提供門道以訪問其後面的房間一樣,此處不太常見的 UI 被收集到單獨的「房間」(通常是其他對話框)中,這些功能可以從主走廊訪問。

或者,提供單個集合中的所有可用功能而不是將不太常見的功能重構到單獨位置的 UI 只是一個儀錶板。

![用於在 Outlook 中公開其他 UI 的走廊概念](../../extensibility/ux-guidelines/media/0704-08_hallway.png "0704-08_Hallway")<br />用於在 Outlook 中公開其他 UI 的走廊概念

##### <a name="adaptive-ui"></a>彈性 UI
根據使用方式或使用者自報體驗顯示或隱藏 UI 是顯示必要 UI 而隱藏其他部分的另一種方法。 Visual Studio 中不建議這樣做,因為用於決定何時顯示或隱藏 UI 的演演演算法可能比較棘手,對於某些情況,規則總是是錯誤的。

## <a name="projects"></a><a name="BKMK_Projects"></a>專案

### <a name="projects-in-the-solution-explorer"></a>解決方案資源管理員中的專案
大多數專案都分類為基於引用、基於目錄或混合的專案。 解決方案資源管理員中同時支援所有三種類型的專案。 處理項目的用戶體驗的根位於此視窗中。 儘管不同的專案節點是引用、目錄或混合模式類型專案,但有一個常見的交互模式,在分到特定於專案的使用者模式之前,應作為起點應用。

專案應始終:

- 支援新增項目資料夾以組織項目內容的能力

- 維護專案持久性的一致模型

專案還應保持一致的交互模型::

- 移除項目項目

- 儲存文件

- 專案屬性編輯

- 在備用檢視中編輯項目

- 拖放作業

### <a name="drag-and-drop-interaction-model"></a>拖放互動模型
專案通常將其分類為基於引用(只能保留對存儲中的專案項的引用)、基於目錄(只能保留物理存儲在專案層次結構中的專案項)或混合(能夠保留引用或物理項)。 IDE 同時適應**解決方案資源管理器**中所有三種類型的專案。

從拖放的角度來看,以下特徵應應用於**解決方案資源管理員**中的每種類型的專案:

- **以參考的專案:** 關鍵是專案正在拖動對存儲中的項的引用。 當基於引用的專案充當移動操作的源時,它應僅從專案中刪除對該專案的引用。 該項目實際上不應從硬碟驅動器中刪除。 當基於引用的專案充當移動(或複製)操作的目標時,它應該添加對原始源項的引用,而不創建項的私有副本。

- **以目錄的項目:** 從拖放的角度來看,專案是圍繞物理項而不是引用進行拖動。 當基於目錄的專案充當移動操作的源時,它最終應該從硬碟驅動器中刪除物理項,並從專案中刪除它。 當基於目錄的專案充當移動(或複製)操作的目標時,它應在其目標位置創建源項的副本。

- **混合目標專案:** 從拖放的角度來看,這種類型的項目的行為基於要拖動的項的性質(對存儲中的項或項本身的引用)。 上面描述了引用和物理項的正確行為。

如果**解決方案資源管理器**中只有一種類型的專案,則拖放操作將非常簡單。 由於每個項目系統都能夠定義自己的拖放行為,因此應遵循某些準則(基於 Windows 資源管理器拖放行為),以確保可預測的使用者體驗:

- **解決方案資源管理員**中未修改的拖動操作(當 Ctrl 和 Shift 鍵均未保持關閉時)應會導致行動操作。

- 換檔拖動操作還應導致移動操作。

- Ctrl 拖動操作應會導致複製操作。

- 基於引用的混合專案系統支援向源項添加連結(或引用)的概念。 當這些項目是拖放操作的目標(當**Ctrl + Shift**被關閉時),它應導致對要新增到項目的項目的參考

並非所有拖放操作都是基於引用、基於目錄和混合專案的組合的明智之舉。 特別是,假裝允許在基於目錄的源專案和基於引用的目標項目之間進行移動操作是有問題的,因為基於源目錄的項目必須在完成移動後刪除源項。 然後,基於目標引用的項目最終將引用已刪除的專案。

假裝允許在這些類型的項目之間進行複製操作也是誤導性的,因為基於目標引用的專案不應創建源項的獨立副本。 同樣,不應允許 Ctrl 和 Shift 拖動到基於目錄的目標專案,因為基於目錄的專案無法保留引用。 在不支援拖放操作的情況下,IDE 應禁止放置,並向用戶顯示無放置游標(如下指標表中所示)。

要正確實現拖放行為,拖動的源專案需要將其性質傳達給目標專案。 (例如,它是基於參考還是基於目錄?)此資訊由源提供的剪貼簿格式指示。 作為拖動(或剪貼簿複製操作)的來源,專案應提供或`CF_VSREFPROJECTITEMS``CF_VSSTGPROJECTITEMS`分別提供,具體取決於專案是基於引用還是基於目錄。 這兩種格式具有相同的資料內容`CF_HDROP`, 這與 Windows 格式類似,只不過字串清單(而不是檔案名`NULL`)是雙`Projref`端終止的字串`IVsSolution::GetProjrefOfItem`清單(`::GetProjrefOfProject`從返回或適當)。

作為放置(或剪貼簿粘貼操作)的目標,專案應接受`CF_VSREFPROJECTITEMS``CF_VSSTGPROJECTITEMS`和 ,儘管拖放操作的確切處理因目標專案和源專案的性質而異。 源項目通過提供`CF_VSREFPROJECTITEMS``CF_VSSTGPROJECTITEMS`還是聲明其性質。 丟棄的目標瞭解其自身性質,因此有足夠的資訊來決定是否應執行移動、複製或連結。 使用者還可以通過按 Ctrl、Shift 或「移動」鍵來修改應執行的拖放操作。 放置目標必須正確指示在其`DragEnter`和`DragOver`方法 中提前執行哪些操作。因此,放置目標必須正確指示該放置目標。 **解決方案資源管理員**自動知道源專案和目標專案是否相同。

特別不支援跨 Visual Studio 實例(例如,從 devenv.exe 的一個實例拖動專案項)。 **解決方案資源管理員**還直接禁用此功能。

使用者應始終能夠通過選擇專案、將其拖動到目標位置以及觀察在刪除專案之前顯示以下滑鼠指標中出現哪種效果來確定拖放操作的效果:

| 滑鼠指標 | Command | 描述 |
| :---: | --- | --- |
| ![滑鼠「不置放」圖示](../../extensibility/ux-guidelines/media/0706-01_mousenodrop.png "0706-01_MouseNoDrop") | 無掉落 | 無法將物料刪除到指定位置。 |
| ![滑鼠「複製」圖示](../../extensibility/ux-guidelines/media/0706-02_mousecopy.png "0706-02_MouseCopy") | [複製] | 專案將複製到目標位置。 |
| ![滑鼠「移動」圖示](../../extensibility/ux-guidelines/media/0706-03_mousemove.png "0706-03_MouseMove") | 移動 | 專案將移動到目標位置。 |
| ![滑鼠「加入參考」圖示](../../extensibility/ux-guidelines/media/0706-04_mouseaddref.png "0706-04_MouseAddRef") | 新增參考 | 對所選項的引用將添加到目標位置。 |

#### <a name="reference-based-projects"></a>建立參考的項目
 下表匯總了應根據源項和為基於引用的目標專案按下的修改器鍵的性質執行的拖放操作::

| 修飾詞 | 類別 | 來源:參考/連結 | 來源:物理項目或檔案系統 (`CF_HDROP`) |
| --- | --- | --- | --- |
| 無修飾子 | 動作 | 移動 | 連結 |
| 無修飾子 | 目標 | 新增對原始項目的參考 | 新增對原始項目的參考 |
| 無修飾子 | 來源 | 移除對原始項目的引言 | 保留原始項目 |
| 無修飾子 | 結果 | `DROPEFFECT_MOVE`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 | `DROPEFFECT_LINK`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 |
| 換檔+拖動 | 動作 | 移動 | 無掉落 |
| 換檔+拖動 | 目標 | 新增對原始項目的參考 | 無掉落 |
| 換檔+拖動 | 來源 | 移除對原始項目的引言 | 無掉落 |
| 換檔+拖動 | 結果 | `DROPEFFECT_MOVE`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 | 無掉落 |
| Ctrl_拖動 | 動作 | [複製] | 無掉落 |
| Ctrl_拖動 | 目標 | 新增對原始項目的參考 | 無掉落 |
| Ctrl_拖動 | 來源 | 保留對原始項目的參考 | 無掉落 |
| Ctrl_拖動 | 結果 | `DROPEFFECT_COPY`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 | 無掉落 |
| Ctrl_Shift_拖動 | 動作 | 連結 | 連結 |
| Ctrl_Shift_拖動 | 目標 | 新增對原始項目的參考 | 新增對原始項目的參考 |
| Ctrl_Shift_拖動 | 來源 | 保留對原始項目的參考 | 保留原始項目 |
| Ctrl_Shift_拖動 | 結果 | `DROPEFFECT_LINK`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 | `DROPEFFECT_LINK`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 |
| Ctrl_Shift_拖動 | 附註 | 與 Windows 資源管理器中快捷方式的拖放行為相同。 ||
| 剪下/ 貼上 | 動作 | 移動 | 連結 |
| 剪下/ 貼上 | 目標 | 新增對原始項目的參考 | 新增對原始項目的參考 |
| 剪下/ 貼上 | 來源 | 保留對原始項目的參考|保留原始項目 |
| 剪下/ 貼上 | 結果 | 專案保留在儲存的原始位置 | 專案保留在儲存的原始位置 |
| 複製/貼上 | 動作 | [複製] | 連結 |
| 複製/貼上 | 來源 | 新增對原始項目的參考 | 新增對原始項目的參考 |
| 複製/貼上 | 結果 | 保留對原始項目的參考 | 保留原始項目 |
| 複製/貼上 | 動作 | 專案保留在儲存的原始位置 | 專案保留在儲存的原始位置 |

#### <a name="directory-based-projects"></a>專案建立目錄的項目
下表匯總了應根據源項和為基於目錄的目標專案按下的修改器鍵的性質執行的拖放操作::

| 修飾詞 | 類別 | 來源:參考/連結 | 來源:物理項目或檔案系統 (`CF_HDROP`) |
|-----------------|----------| - | - |
| 無修飾子 | 動作 | 移動 | 移動 |
| 無修飾子 | 目標 | 複製項目複製到目標位置 | 複製項目複製到目標位置 |
| 無修飾子 | 來源 | 移除對原始項目的引言 | 移除對原始項目的引言 |
| 換檔+拖動 | 動作 | 移動 | 移動 |
| 換檔+拖動 | 目標 | 複製項目複製到目標位置 | 複製項目複製到目標位置 |
| 換檔+拖動 | 來源 | 移除對原始項目的引言 | 從原始位置移除項目 |
| 換檔+拖動 | 結果 | `DROPEFFECT_MOVE`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 | `DROPEFFECT_MOVE`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 |
| Ctrl_拖動 | 動作 | [複製] | [複製] |
| Ctrl_拖動 | 目標 | 複製項目複製到目標位置 | 複製項目複製到目標位置 |
| Ctrl_拖動 | 來源 | 保留對原始項目的參考 | 保留對原始項目的參考 |
| Ctrl_拖動 | 結果 | `DROPEFFECT_COPY`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 | `DROPEFFECT_COPY`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 |
| Ctrl_Shift_拖動 | | 無掉落 | 無掉落 |
| 剪下/ 貼上 | 動作 | 移動 | 移動 |
| 剪下/ 貼上 | 目標 | 複製項目複製到目標位置 | 複製項目複製到目標位置 |
| 剪下/ 貼上 | 來源 | 移除對原始項目的引言 | 從原始位置移除項目 |
| 剪下/ 貼上 | 結果 | 專案保留在儲存的原始位置 | 此項目從儲存中的原始位置中移除 |
| 複製/貼上 | 動作 | [複製] | [複製] |
| 複製/貼上 | 目標 | 新增對原始項目的參考 | 複製項目複製到目標位置 |
| 複製/貼上 | 來源 | 保留原始項目 | 保留原始項目 |
| 複製/貼上 | 結果 | 專案保留在儲存的原始位置 | 專案保留在原始位置的儲存 |

#### <a name="mixed-target-projects"></a>混合目標項目
下表匯總了應根據源項和為混合目標專案按下的修改器鍵的性質執行的拖放操作(以及剪切/複製/粘貼)操作:

| 修飾詞 | 類別 | 來源:參考/連結 | 來源:物理項目或檔案系統 (`CF_HDROP`) |
| --- | --- | --- | --- |
| 無修飾子 | 動作 | 移動 | 移動 |
| 無修飾子 | 目標 | 新增對原始項目的參考 | 複製項目複製到目標位置 |
| 無修飾子 | 來源 | 移除對原始項目的引言 | 移除對原始項目的引言 |
| 無修飾子 | 結果 | `DROPEFFECT_ MOVE`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 | `DROPEFFECT_ MOVE`傳回為`::Drop`要儲存的檔案中移除 |
| 換檔+拖動 | 動作 | 移動 | 移動 |
| 換檔+拖動 | 目標 | 新增對原始項目的參考 | 複製項目複製到目標位置 |
| 換檔+拖動 | 來源 | 移除對原始項目的引言 | 從原始位置移除項目 |
| 換檔+拖動 | 結果 | `DROPEFFECT_ MOVE`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 | `DROPEFFECT_ MOVE`傳回為`::Drop`要儲存的檔案中移除 |
| Ctrl_拖動 | 動作 | [複製] | [複製] |
| Ctrl_拖動 | 目標 | 新增對原始項目的參考 | 複製項目複製到目標位置 |
| Ctrl_拖動 | 來源 | 保留對原始項目的參考 | 保留原始項目 |
| Ctrl_拖動 | 結果 | `DROPEFFECT_ COPY`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 | `DROPEFFECT_ COPY`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 |
| Ctrl_Shift_拖動 | 動作 | 連結 | 連結 |
| Ctrl_Shift_拖動 | 目標 | 新增對原始項目的參考 | 新增對原始源項目的參考 |
| Ctrl_Shift_拖動 | 來源 | 保留對原始項目的參考 | 保留原始項目 |
| Ctrl_Shift_拖動 | 結果 | `DROPEFFECT_ LINK`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 | `DROPEFFECT_ LINK`傳回,因為操作`::Drop`和 專案保留在儲存中的原始位置 |
| 剪下/ 貼上 | 動作 | 移動 | 移動 |
| 剪下/ 貼上 | 目標 | 複製項目複製到目標位置 | 複製項目複製到目標位置 |
| 剪下/ 貼上 | 來源 | 移除對原始項目的引言 | 從原始位置移除項目 |
| 剪下/ 貼上 | 結果 | 專案保留在儲存的原始位置 | 此項目從儲存中的原始位置中移除 |
| 複製/貼上 | 動作 | [複製] | [複製] |
| 複製/貼上 | 目標 | 新增對原始項目的參考 | 複製項目複製到目標位置 |
| 複製/貼上 | 來源 | 保留原始項目 | 保留原始項目 |
| 複製/貼上 | 結果 | 專案保留在儲存的原始位置 | 專案保留在儲存的原始位置 |

在**解決方案資源管理員**中實現拖動時,應考慮這些詳細資訊:

- 為多種選擇方案設計。

- 檔名(完整路徑)必須在整個目標專案中是唯一的,否則不應允許刪除。

- 資料夾名稱必須是唯一的(不區分大小寫)的級別。

- 在拖動時打開或關閉的文件之間存在行為差異(上述方案未提及)。

- 頂級文件的行為與資料夾中的檔略有不同。

需要注意的另一個問題是如何處理具有打開設計器或編輯器的項目的移動操作。 預期行為如下(這適用於所有項目類型):

1. 如果打開的編輯器/設計器沒有任何未儲存的更改,則應靜默關閉編輯器/設計器視窗。

2. 如果開啟的編輯器/設計器確實有未儲存的更改,則拖動源應等待放置,然後要求使用者在關閉視窗之前保存未提交的更改,提示如下所示:

    ```
    ==========================================================
         One or more open documents have unsaved changes.
    Do you want to save uncommitted changes before proceeding?
                      [Yes]  [No]  [Cancel]
    ==========================================================
    ```

這使用戶有機會在目標複製之前保存正在進行的工作。 已添加新方法`IVsHierarchyDropDataSource2::OnBeforeDropNotify`以啟用此處理。

然後,目標將複製專案在存儲中的狀態(如果用戶選擇 **"否**",則不包括編輯器中未保存的更改)。 目標完成其複製 (in)`IVsHierarchyDropDataSource::Drop`後,源將有機會完成行動操作的刪除部分(在中`IVsHierarchyDropDataSource::OnDropNotify`)。

任何未保存更改的編輯器都應保留打開狀態。 對於具有未保存更改的文檔,這意味著將執行移動操作的副本部分,但刪除部分將中止。 在使用者選擇 **「否」** 的多個選擇方案中,不應關閉或刪除具有未儲存更改的文檔,但應關閉和刪除那些沒有未儲存更改的文檔。
