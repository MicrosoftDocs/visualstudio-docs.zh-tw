---
title: CA2016：將 CancellationToken 參數傳遞給使用該參數的方法
ms.date: 06/18/2020
ms.topic: reference
f1_keywords:
- ForwardCancellationTokenToInvocations
- CA2016
helpviewer_keywords:
- ForwardCancellationTokenToInvocations
- CA2016
author: carlossanlop
ms.author: calope
manager: jeffhand
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 722f5bf38a43785c06aea12743879accc5881691
ms.sourcegitcommit: d8609a78b460d4783f5d59c0c89454910a4dbd21
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 08/14/2020
ms.locfileid: "88238292"
---
# <a name="ca2016-forward-the-cancellationtoken-parameter-to-methods-that-take-one"></a>CA2016：將 CancellationToken 參數傳遞給使用該參數的方法

|Item|值|
|-|-|
|TypeName|ForwardCancellationTokenToInvocations|
|CheckId|CA2016|
|類別|Microsoft。效能|
|中斷變更|不中斷|

## <a name="cause"></a>原因

此規則會找出可接受參數的方法叫用 <xref:System.Threading.CancellationToken> ，但不會傳遞任何，並建議將父系方法轉寄 `CancellationToken` 給它們。

## <a name="rule-description"></a>規則描述

此規則會分析採用做 `CancellationToken` 為最後一個參數的方法定義，然後分析其主體中叫用的所有方法。 如果任何方法調用可以接受當做 `CancellationToken` 最後一個參數，或具有接受當做最後一個參數的多載，則規則會 `CancellationToken` 建議改用該選項，以確保取消通知會傳播到可接聽它的所有作業。

> [!NOTE]
> 在可用類型的所有 .NET 版本中，都可以使用 [規則 CA2016] `CancellationToken` 。 請參閱 CancellationToken 「適用于」 [一節](https://docs.microsoft.com/dotnet/api/system.threading.cancellationtoken#moniker-applies-to)

## <a name="how-to-fix-violations"></a>如何修正違規

您可以手動修正這些問題，也可以選擇讓 Visual Studio 為您執行此動作，方法是將滑鼠停留在方法調用旁顯示的燈泡上，然後選取建議的變更。

下列範例顯示兩個建議的變更：

![規則 CA2016-將 CancellationToken 參數轉送至接受一個的方法](media/ca2016-diagnose.png)

如果您不在意將已取消的作業通知轉送至較低的方法叫用，則可放心抑制此規則的違規。
您也可以 `default` 在 Visual Basic) 中明確地傳入 c # (`Nothing` <xref:System.Threading.CancellationToken.None> ，或隱藏規則違規。

此規則可以偵測到各種違規。 下列範例顯示規則可以偵測的案例：

##### <a name="example-1"></a>範例 1

此規則會建議將 `c` 參數從轉送 `MyMethod` 至 `MyMethodWithDefault` 調用，因為方法會定義選擇性的 token 參數：

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

##### <a name="fix"></a>修正

轉送 `c` 參數：
```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(c);
        }
```

如果您不在意將取消通知轉送至較低的調用，您可以：

明確傳遞 `default` ：
```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(default);
        }
```

或明確地傳遞 `CancellationToken.None` ：
```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault(CancellationToken.None);
        }
```

##### <a name="example-2"></a>範例 2

此規則會建議將 `c` 參數從轉送 `MyMethod` 至 `MyMethodWithDefault` 調用，因為方法具有接受 `CancellationToken` 參數的多載：

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload()
        {
        }

        public static void MyMethodWithOverload(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```

##### <a name="fix"></a>修正

轉送 `c` 參數：
```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(c);
        }
```

如果您不在意將取消通知轉送至較低的調用，您可以：

明確傳遞 `default` ：
```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(default);
        }
```

或明確地傳遞 `CancellationToken.None` ：
```csharp
        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload(CancellationToken.None);
        }
```


#### <a name="no-diagnosis"></a>沒有診斷

##### <a name="example-1"></a>範例 1

`CancellationToken`父方法中的參數不在最後一個位置：

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c, int lastParameter)
        {
            MyMethodWithDefault();
        }
    }
}
```

##### <a name="example-2"></a>範例 2

`CancellationToken`預設方法中的參數不在最後一個位置：

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default, int lastParameter = 0)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

##### <a name="example-3"></a>範例 3

多載 `CancellationToken` 方法中的參數不在最後一個位置：

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload(int lastParameter)
        {
        }
        public static void MyMethodWithOverload(CancellationToken ct, int lastParameter)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```

##### <a name="example-4"></a>範例 4

Parent 方法會定義一個以上的 `CancellationToken` 參數：

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken ct = default)
        {
        }

        public static void MyMethod(CancellationToken c1, CancellationToken c2)
        {
            MyMethodWithDefault();
        }
    }
}
```

##### <a name="example-5"></a>範例 5

具有預設值的方法會定義一個以上的 `CancellationToken` 參數：

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithDefault(CancellationToken c1 = default, CancellationToken c2 = default)
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithDefault();
        }
    }
}
```

##### <a name="example-6"></a>範例 6

方法多載會定義一個以上的 `CancellationToken` 參數：

```csharp
using System.Threading;

namespace ConsoleApp
{
    public static class MyTestClass
    {
        public static void MyMethodWithOverload(CancellationToken c1, CancellationToken c2)
        {
        }

        public static void MyMethodWithOverload()
        {
        }

        public static void MyMethod(CancellationToken c)
        {
            MyMethodWithOverload();
        }
    }
}
```
