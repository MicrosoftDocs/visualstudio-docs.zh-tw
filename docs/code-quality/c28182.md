---
title: C28182
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C28182
helpviewer_keywords:
- C28182
ms.assetid: efec8b1f-8994-4a09-aaaf-6afaadfde883
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 42ca9d69cb4186ae82f71bf0014b27bb0101d253
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/07/2019
ms.locfileid: "72015107"
---
# <a name="c28182"></a>C28182
警告 C28182：取值的指標為 NULL。

 **其他資訊**： *\<pointer1 >* 包含與 *@no__t 4pointer2 >* 相同的 Null 值（ *6note） @no__t*

 當程式碼分析工具確認指標可以是 Null 時，就會報告這個警告。 如果有未確認的實例可能會在追蹤中發生錯誤，則程式碼分析工具會將第一個實例的行號加入至警告訊息，讓您可以變更程式碼來處理所有的實例。

 *@no__t 1pointer2 >* 已確認為可能是 Null。 *@no__t 1pointer1 >* 包含與*pointer2*相同的值，而且正在進行取值。 因為這些指標可能會在程式碼中的不同位置上，所以會回報這兩者，讓您可以判斷程式碼分析工具報告此警告的原因。

 如果條件的先前未確認實例存在，則會將 *@no__t 1note >* 取代為此文字：「請參閱行 *\<number >* ，以取得可能發生這種情況的先前位置。」

## <a name="example"></a>範例
 下列範例會顯示可能導致程式碼分析工具產生此警告訊息的程式碼。 在此範例中，程式碼分析工具會判斷 `if` 語句中的 `pNodeFree` 是 Null，而且會採用 `if` 主體中的程式碼路徑。 不過，因為 `nBlockSize` 可能是零，所以不會執行 `for` 語句的主體，而且 `pNodeFree` 會保持未修改狀態。 `pNodeFree` 接著會指派給 `pNode`，而 `pNode` 則會在進行 Null 取值時使用。

```
typedef struct xlist {
    struct xlist *pNext;
    struct xlist *pPrev;
} list;

list *pNodeFree;
list *masterList;
int nBlockSize;

void fun()
{
    if (pNodeFree == 0)
    {
        list *pNode = masterList;

        for (int i = nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = pNodeFree;
            pNodeFree = pNode;
        }
    }

    list* pNode = pNodeFree;
    pNode->pPrev = 0;
}
```

 程式碼分析工具會報告下列警告：

```
:\sample\testfile.cpp(24) : warning C28182: Dereferencing NULL pointer. 'pNode' contains the same NULL value as 'pNodeFree' did.: Lines: 12, 14, 16, 23, 24
```

## <a name="example"></a>範例
 更正先前範例的其中一個方法是先檢查 `pNode`，再將它取值，以便 averted Null 取值。 下列程式碼會顯示這項更正。

```
typedef struct xlist {
    struct xlist *pNext;
    struct xlist *pPrev;
} list;

list *pNodeFree;
list *masterList;
int nBlockSize;

void fun()
{
    if (pNodeFree == 0)
    {
        list *pNode = masterList;

        for (int i = nBlockSize-1; i >= 0; i--, pNode--)
        {
            pNode->pNext = pNodeFree;
            pNodeFree = pNode;
        }
    }

    list* pNode = pNodeFree;
    if(pNode != 0)
      pNode->pPrev = 0;
}
```