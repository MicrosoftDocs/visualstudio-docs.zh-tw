---
title: C6284
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6284
helpviewer_keywords:
- C6284
ms.assetid: f3633df6-2978-4899-8c0b-b495bd869e1a
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: d99c66fd960787b95168112490a604305cc6ec0d
ms.sourcegitcommit: 5f6ad1cefbcd3d531ce587ad30e684684f4c4d44
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/22/2019
ms.locfileid: "72746462"
---
# <a name="c6284"></a>C6284
警告 C6284：當呼叫 \<函式 > 時需要字串，做為參數 '% d ' 傳遞的物件。

 此警告表示格式字串指定了字串，例如，`printf` 或 `scanf`的 `%s` 規格，但已改為傳遞C++物件。

 此缺陷可能會產生不正確的輸出或當機。

 這則訊息通常是因為將C++物件（例如，`std::string`，`CComBSTR` 或 `bstr_t`）傳遞至 C `printf` 樣式呼叫所造成。 視C++類別的執行而定，也就是說，如果定義了正確的轉型運算子，則C++每當需要 C 字串時，都可以透明地使用字串物件;不過，因為 `printf` 樣式函式的參數本質上不具類型，所以不會轉換成字串。

 視物件而定，將 `static_cast` 運算子插入適當的字串類型（例如，`char *` 或 `TCHAR``*`），或呼叫會在 `std::string` 實例上傳回字串的成員函式（例如 `c_str()`）可能會很適當。

## <a name="example"></a>範例
 下列程式碼會產生這個警告，因為 `CComBSTR` 會傳遞給 `sprintf` 函式：

```
#include <atlbase.h>
#include <stdlib.h>

void f()
{
  char buff[50];
  CComBSTR bstrValue("Bye");

  sprintf(buff,"%ws",bstrValue);
}
```

 下列程式碼會使用靜態轉換來更正此警告：

```
#include <atlbase.h>
#include <stdlib.h>

void f()
{
  char buff[50];
  CComBSTR bstrValue("Bye");

  sprintf_s(buff,50,"%ws",static_cast<wchar_t *>(bstrValue));
}
```

## <a name="see-also"></a>另請參閱

- [static_cast 運算子](/cpp/cpp/static-cast-operator)
- [sprintf_s、_sprintf_s_l、swprintf_s、_swprintf_s_l](/cpp/c-runtime-library/reference/sprintf-s-sprintf-s-l-swprintf-s-swprintf-s-l)
