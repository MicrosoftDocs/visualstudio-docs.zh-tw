---
title: C26400
ms.date: 08/02/2017
ms.topic: conceptual
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.assetid: b27e1c6d-8b52-40b3-9760-b93afef19c7a
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: ea1e4a708765a173231689cd9c2037a4a20158af
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/07/2019
ms.locfileid: "72016613"
---
# <a name="c26400-no_raw_pointer_assignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT

這種檢查有助於強制執行 @no__t 0rule 的 I. 11：絕對不會使用原始指標（T @ no__t-0）將擁有權轉移 *，這是規則 @no__t 的子集-2R。3：原始指標（T @ no__t-0）為非擁有。 * 具體來說，它會在任何呼叫 operator `new` 時發出警告，將其結果儲存在原始指標類型的變數中。 如果將結果指派給原始指標，它也會警告呼叫傳回 `gsl::owner<T>` 的函式。 這裡的想法是，您應該清楚地陳述記憶體資源的擁有權。 如需詳細資訊，請參閱[ C++核心指導方針](http://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management)。

若要修正此問題，最簡單的方法是使用 `auto` 宣告（如果在變數宣告中立即指派資源）。 如果無法這麼做，我們建議您使用類型 `gsl::owner<T>`。 以 operator `new` 初始化的 `auto` 宣告為「擁有者」，因為我們假設任何配置的結果都是隱含的擁有者指標。 我們會將此假設轉移至 @no__t 0 變數，並將它視為 `owner<T>`。

如果這項檢查旗標呼叫傳回 `owner<T>` 的函式，這可能表示程式碼中有合法的錯誤（bug）。 基本上，它會指向程式碼遺漏擁有權的明確概念（也可能是資源本身）的位置。

## <a name="remarks"></a>備註

此規則目前只會檢查本機變數。 如果配置已指派給型式參數、全域變數、類別成員等等，則不會加上旗標。 這類案例的適當涵蓋範圍是未來工作的一部分。

## <a name="example-1-simple-allocation"></a>範例 1：簡單配置

```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>範例 2：簡單配置（使用 gsl：： owner @ no__t-0T >）來修正

```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK

Example 3: Simple allocation (fixed with auto)
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```
