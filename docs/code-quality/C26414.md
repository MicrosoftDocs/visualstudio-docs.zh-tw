---
title: C26414
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26414
helpviewer_keywords:
- C26414
ms.assetid: dd875d0c-6752-4491-a533-3e8831795fbc
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 8ced283edb792ee917706974070dce407cc29f5a
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011685"
---
# <a name="c26414-reset_local_smart_ptr"></a>C26414 RESET_LOCAL_SMART_PTR

「移動、複製、重新指派或重設本機智能型指標」。

核心指導方針： **C++** R. 5：偏好設定範圍的物件，不需要堆積-不必要地配置

智慧型指標對動態資源管理很方便，但不一定都是必要的。 例如，您可以輕鬆地建立本機動態緩衝區（有時更有效率），由標準容器管理。 對於單一物件，完全不需要進行動態配置（例如，如果這類物件絕對不會 outlive 其 creator 函式），而且可以用區域變數來取代。 當案例需要變更擁有權，亦即多次重新指派動態資源或多個路徑時，智慧型指標就會變得很方便。 這也包括從外部程式碼取得資源的情況，以及使用智慧型指標來擴充資源的存留期。

## <a name="remarks"></a>備註

- 除了標準 std：： unique_pointer 和 std：： shared_pointer 範本，這項檢查也會辨識可能是智慧型指標的使用者定義類型。 這類類型應該會定義下列作業：
  - 多載的取值或成員存取運算子，其為公用且未標示為已刪除;
  - 不會刪除也不會預設的公用析構函式。 這包括明確定義為空白的析構函數。
  - 類型 Microsoft：： WRL：： ComPtr 的行為就像是共用指標，但它通常用於會受到 COM 存留期管理影響的特定案例中。 為了避免過多的干擾，此型別會被篩選掉。
  - 這項檢查會尋找指派給智慧型指標的明確本機配置，以識別範圍變數是否可以做為替代字。 除了 operator new 的直接呼叫之外，也會將 std：： make_unique 和 std：： make_shared 等特殊函式視為直接配置。

## <a name="example"></a>範例

動態緩衝區

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::make_unique<char[]>(f.size()); // C26414
    f.unpack(buffer.get());
    // ...
}
```

動態緩衝區–由容器取代

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::vector<char>(f.size());
    f.unpack(buffer.data());
    // ...
}
```
