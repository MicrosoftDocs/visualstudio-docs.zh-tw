---
title: CA1021：避免使用 out 參數
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA1021
- AvoidOutParameters
helpviewer_keywords:
- AvoidOutParameters
- CA1021
ms.assetid: 970f2304-842c-4fb7-9734-f3871da8d479
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 579b04f26af972ac025b0bfc07bc8dc9eb636d12
ms.sourcegitcommit: 98421670ed0b8170aaa32d3d6f8681298f401a1d
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/18/2020
ms.locfileid: "81638022"
---
# <a name="ca1021-avoid-out-parameters"></a>CA1021：避免使用 out 參數

|||
|-|-|
|TypeName|AvoidOutParameters|
|CheckId|CA1021|
|類別|微軟.設計|
|重大變更|中斷|

## <a name="cause"></a>原因
公共型態的公共或受保護方法有`out`參數 。

預設情況下,此規則僅檢視外部可見類型,但這是[可設定的](#configurability)。

## <a name="rule-description"></a>規則描述
按引用傳遞類型(使用`out``ref`或 )需要體驗指標,瞭解值類型和引用類型有何不同,以及具有多個返回值的處理方法。 此外,參數之間的差異`out``ref`並不被廣泛理解。

當引用類型通過"引用"傳遞時,該方法打算使用 參數返回物件的不同實例。 通過引用傳遞引用類型也稱為使用雙指標、指向指標的指標或雙間接。 通過使用預設調用約定(即傳遞"按值"),採用引用類型的參數已經接收指向物件的指標。 指標(而不是指向的物件)由值傳遞。 按值傳遞意味著該方法無法更改指標以使其指向引用類型的新實例。 但是,它可以更改它指向的物件的內容。 對於大多數應用程序來說,這就足夠了,並產生所需的行為。

如果方法必須返回其他實例,請使用 方法的返回值來實現此目的。 有關在<xref:System.String?displayProperty=fullName>字串上操作並返回字串的新實例的各種方法,請參閱 類。 使用此模型時,調用方必須決定是否保留原始物件。

儘管返回值是司空見慣和大量使用,但正確應用`out`和`ref`參數需要中間設計和編碼技能。 為一般受眾設計的庫架構師不應期望使用者掌握使用`out``ref`或 參數。

## <a name="how-to-fix-violations"></a>如何修正違規
要修復由值類型引起的違反此規則的衝突,讓 方法返回該對象作為其返回值。 如果方法必須返回多個值,則重新設計它以返回保存值的物件的單個實例。

要修復由引用類型引起的對此規則的違反,請確保所需的行為是返回引用的新實例。 如果是,則該方法應使用其返回值執行此操作。

## <a name="when-to-suppress-warnings"></a>何時禁止警告
可以安全地禁止顯示此規則的警告。 但是,此設計可能會導致可用性問題。

## <a name="configurability"></a>可設定性

如果從[FxCop 分析器](install-fxcop-analyzers.md)運行此規則(而不是使用舊版分析),則可以根據代碼庫的可存取性配置要運行此規則的哪些部分。 例如,要指定規則應僅針對非公共 API 曲面運行,請在專案中將以下鍵值對新增到 .editorconfig 檔案中:

```ini
dotnet_code_quality.ca1021.api_surface = private, internal
```

您可以僅為此規則、所有規則或此類別(設計)中的所有規則配置此選項。 有關詳細資訊,請參閱配置[FxCop 分析器](configure-fxcop-analyzers.md)。

## <a name="example"></a>範例
以下庫顯示了一個類的兩個實現,這些實現生成對用戶反饋的回應。 第一個實現`BadRefAndOut`( ) 強制庫使用者管理三個返回值。 第二個實現`RedesignedRefAndOut`( ) 通過返回容器類的`ReplyData`實例 ( ) 來簡化用戶體驗,該實例將數據作為單個單元管理。

[!code-csharp[FxCop.Design.NoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_1.cs)]

## <a name="example"></a>範例
以下應用程式說明瞭使用者的經驗。 對重新設計的庫(`UseTheSimplifiedClass`方法) 的呼叫更為簡單,該方法傳回的資訊也易於管理。 這兩種方法的輸出相同。

[!code-csharp[FxCop.Design.TestNoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_2.cs)]

## <a name="example"></a>範例
下面的示例庫說明了如何使用`ref`引用類型的參數,並展示了實現此功能的更好方法。

[!code-csharp[FxCop.Design.RefByRefNo#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_3.cs)]

## <a name="example"></a>範例
以下應用程式調用庫中的每種方法來演示該行為。

[!code-csharp[FxCop.Design.TestRefByRefNo#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_4.cs)]

這個範例會產生下列輸出：

```txt
Changing pointer - passed by value:
12345
12345
Changing pointer - passed by reference:
12345
12345 ABCDE
Passing by return value:
12345 ABCDE
```

## <a name="try-pattern-methods"></a>嘗試模式方法

### <a name="description"></a>描述
實現 **「\<嘗試 某些內容>** 模式<xref:System.Int32.TryParse%2A?displayProperty=fullName>的方法(如 )不會引發此衝突。 下面的示例顯示了實現<xref:System.Int32.TryParse%2A?displayProperty=fullName>該方法的結構(值類型)。

### <a name="code"></a>程式碼
[!code-csharp[FxCop.Design.TryPattern#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_5.cs)]

## <a name="related-rules"></a>相關規則
[CA1045：不要以傳址方式傳遞類型](../code-quality/ca1045.md)
