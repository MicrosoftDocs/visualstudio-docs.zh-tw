---
title: CA2000：必須在超出範圍前處置物件
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
ms.assetid: 0c3d7d8d-b94d-46e8-aa4c-38df632c1463
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 387f1c3d763b15cdbf9ff3cc21375958dc213058
ms.sourcegitcommit: 4bcd6abb89feff1cf8251e3ded73fdc30b67e347
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/17/2020
ms.locfileid: "81615575"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a>CA2000：必須在超出範圍前處置物件

|||
|-|-|
|TypeName|DisposeObjectsBeforeLosingScope|
|CheckId|CA2000|
|類別|微軟.可靠性|
|重大變更|不中斷|

## <a name="cause"></a>原因

將創建類型的<xref:System.IDisposable>本地物件,但在對該物件的所有引用都不在範圍之前,不會釋放該物件。

預設情況下,此規則分析整個代碼庫,但這是[可設定的](#configurability)。

## <a name="rule-description"></a>規則描述

如果在對該物件的所有引用都不在範圍之前未顯式釋放該物件,則當垃圾回收器運行物件的終結器時,該物件將在某個不確定的時間釋放。 由於可能發生異常事件,阻止物件的終結器運行,因此應顯式釋放該物件。

### <a name="special-cases"></a>特殊案例

即使未釋放物件,規則 CA2000 也不會為以下類型的本地物件觸發:

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.StringReader?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

將其中一種類型的物件傳遞給構造函數,然後將其分配給欄位指示釋放*所有權轉移到*新構造的類型。 也就是說,新構造的類型現在負責處理物件。 如果代碼將其中一種物件傳遞給構造函數,則即使該物件未在其所有引用都出範圍之前釋放,也不會違反規則 CA2000。

## <a name="how-to-fix-violations"></a>如何修正違規

要修復違反此規則的行為,請先<xref:System.IDisposable.Dispose%2A>調用物件之前,對物件的所有引用都已出範圍。

可以使用[`using`語句](/dotnet/csharp/language-reference/keywords/using-statement)([`Using`](/dotnet/visual-basic/language-reference/statements/using-statement)在 Visual Basic 中<xref:System.IDisposable>)來換行 實現的物件。 以這種方式包裝的物件將自動在`using`塊的末尾釋放。 但是,不應或不能使用`using`語句處理以下情況:

- 要返回可支配物件,該對象必須構造`try/finally``using`在 塊外的塊中。

- 不要在`using`語句的構造函數中初始化可支配對象的成員。

- 當僅受一個異常處理程序保護的構造函數嵌套在[`using`語句的採集部分](/dotnet/csharp/language-reference/language-specification/statements#the-using-statement)時,外部構造函數中的失敗可能會導致嵌套構造函數創建的物件永遠不會關閉。 在下面的示例中,構造函數中的<xref:System.IO.StreamReader>故障可能導致<xref:System.IO.FileStream>對象永遠不會關閉。 在這種情況下,CA2000 會標記違反規則的行為。

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- 動態物件應使用陰影對象來<xref:System.IDisposable>實現 對象的處置模式。

## <a name="when-to-suppress-warnings"></a>何時禁止警告

除非執行此規則的警告,否則不要禁止顯示此規則的警告:

- 您已呼叫物件上調的方法`Dispose`,例如<xref:System.IO.Stream.Close%2A>
- 引發警告的方法傳回環<xref:System.IDisposable>繞 物件的物件
- 分配方法沒有處置擁有權;也就是說,釋放物件的責任將轉移到在 方法中創建並返回到調用方的另一個物件或包裝器

## <a name="configurability"></a>可設定性

如果從[FxCop 分析器](install-fxcop-analyzers.md)運行此規則(而不是使用舊版分析),則可以為此規則配置分析。

### <a name="excluded-symbol-names"></a>排除符號名稱

您可以配置代碼庫的哪些部分要從分析中排除。 例如,要指定規則不應在名稱`MyType`類型中的任何代碼上運行,請在專案中將以下鍵值對添加到 .editorconfig 檔案中:

```ini
dotnet_code_quality.CA2000.excluded_symbol_names = MyType
```

選項值中允許的符號名稱格式(以"*"分隔):
  - 只設定符號名稱(包括名稱的所有符號,而不考慮包含的類型或命名空間)
  - 符號[的文件 ID 格式](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)完全限定的名稱。 每個符號名稱都需要一個符號類型首碼,例如方法的"M:"首碼、類型的"T:"首碼、命名空間的"N:"首碼等。
  - `.ctor`對於建構函數和`.cctor`靜態建構函數

範例：

| 選項值 | 摘要 |
| --- | --- |
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType` | 符合編譯中名為「MyType」的所有符號
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType1|MyType2` | 在編譯中符合名為「MyType1」或「MyType2」的所有符號
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | 將特定方法「MyMethod」與給定的完全限定簽名匹配
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | 將特定方法「MyMethod1」和「MyMethod2」與各自的完全限定簽名匹配

您可以僅為此規則、所有規則或此類別(設計)中的所有規則配置所有這些選項。 有關詳細資訊,請參閱配置[FxCop 分析器](configure-fxcop-analyzers.md)。

## <a name="related-rules"></a>相關規則

- [CA2213：可處置的欄位應該受到處置](../code-quality/ca2213.md)
- [CA2202：不要多次處置物件](../code-quality/ca2202.md)

## <a name="example"></a>範例

如果要實現返回可支配物件的方法,請使用沒有 catch 塊的 try/finally 塊來確保物件已釋放。 通過使用 try/finally 塊,允許在故障點引發異常並確保物件已釋放。

在 OpenPort1 方法中,打開可序列化物件串列埠或調用某個方法的調用可能會失敗。 在此實現上引發 CA2000 警告。

OpenPort2 方法中,兩個串列埠物件聲明並設定為 null:

- `tempPort`,用於測試方法操作是否成功。

- `port`,用於方法的返回值。

`tempPort`在塊中建構和打開,`try`並且在`try`同 一塊中執行任何其他必需的工作。 `try`在區塊的末尾,開啟的連接埠分配給`port`將傳回的`tempPort`物件, 並將`null`物件設定為 。

區`finally`塊 檢查`tempPort`的值 。 如果它不是 null,則方法中的操作已失敗,`tempPort`並且已關閉以確保釋放任何資源。 如果該方法的操作成功,則返回的埠物件將包含打開的 SerialPort 物件,如果操作失敗,該物件將為空。

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example"></a>範例

默認情況下,Visual Basic 編譯器具有所有算術運算符檢查溢出。 因此,任何可視基本算術運算都可能會<xref:System.OverflowException>引發 。 這可能導致 CA2000 等規則中的意外衝突。 例如,以下 CreateReader1 函數將生成 CA2000 衝突,因為 Visual Basic 編譯器正在發出溢出檢查指令,用於添加該指令,該指令可能會引發導致不釋放 StreamReader 的異常。

要解決此問題,可以禁用專案中 Visual Basic 編譯器發出溢出檢查,也可以像下面的 CreateReader2 函數中那樣修改代碼。

要關閉溢出檢查的發出,請右鍵按一下解決方案資源管理員中的項目名稱,**然後按下屬性**。 按下 **「編譯**」,按下 **「高級編譯選項**」,然後單擊 **「刪除整數溢出檢查**」。

[!code-vb[FxCop.Reliability.CA2000.DisposeObjectsBeforeLosingScope#1](../code-quality/codesnippet/VisualBasic/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb)]

## <a name="see-also"></a>另請參閱

- <xref:System.IDisposable>
- [Dispose 模式](/dotnet/standard/design-guidelines/dispose-pattern)
