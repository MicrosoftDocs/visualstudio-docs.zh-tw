---
title: 使用 Microsoft Fakes 在測試期間隔離程式碼
description: 瞭解 Microsoft Fakes 如何使用存根或填充碼取代應用程式的其他部分，協助您隔離要測試的程式碼。
ms.custom: SEO-VS-2020
ms.date: 06/03/2020
ms.topic: how-to
ms.author: mikejo
manager: jmartens
ms.workload:
- multiple
author: mikejo5000
dev_langs:
- VB
- CSharp
ms.openlocfilehash: e58a9c6477568843141a73ece002d1911280d7ab
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 02/08/2021
ms.locfileid: "99916451"
---
# <a name="isolate-code-under-test-with-microsoft-fakes"></a>使用 Microsoft Fakes 隔離測試中的程式碼

Microsoft Fakes 會以「虛設常式」或「填充碼」取代應用程式的其他部分，協助您隔離要測試的程式碼。 這些是受測試所控制的一些程式碼片段。 藉由隔離待測的程式碼，您可以在正確的位置尋找測試失敗的原因。 即使應用程式的其他部分還無法運作，您也可以利用虛設常式和填充碼。

Fakes 分為兩種類別：

- [虛設常式](#get-started-with-stubs)會以一小段實作相同介面的類別取代類別。  若要使用虛設常式，您所設計的應用程式必須讓每個元件只相依於介面，而不相依於其他元件。 (「元件」表示一起設計及更新的類別或類別群組，通常會包含在組件中)。

- [填充碼](#get-started-with-shims)會在執行階段修改應用程式的編譯程式碼，以便執行您的測試所提供的填充碼，而不是進行指定的方法呼叫。 您可以使用填充碼取代您無法修改的組件 (例如 .NET 組件) 的呼叫。

![Fakes 會取代其他元件](../test/media/fakes-2.png)

**需求**

- Visual Studio Enterprise
- .NET Framework 專案
::: moniker range=">=vs-2019"
- 在 Visual Studio 2019 Update 6 中預覽的 .NET Core 和 SDK 樣式專案支援，預設會在 Update 8 中啟用。 如需詳細資訊，請參閱 [適用于 .Net Core 和 SDK 樣式專案的 Microsoft Fakes](/visualstudio/releases/2019/release-notes#microsoft-fakes-for-net-core-and-sdk-style-projects)。
::: moniker-end

> [!NOTE]
> - 使用 Visual Studio 分析不適用於使用 Microsoft Fakes 的測試。

## <a name="choose-between-stub-and-shim-types"></a>在虛設常式和填充碼類型之間選擇
由於您會同時開發及更新這些類別，因此您通常會將 Visual Studio 專案視為元件。 您可以考慮針對專案對方案中其他專案或專案所參考之其他組件的呼叫使用虛設常式和填充碼。

一般方針是，對 Visual Studio 方案中的呼叫使用虛設常式，而對其他參考組件的呼叫則使用填充碼。 這是因為在您自己的方案中，依虛設常式需要的方式定義介面以分隔元件是很好的作法。 但是，外部元件（例如 *System.dll* ）通常不會以個別的介面定義提供，因此您必須改為使用填充碼。

其他考量為：

**效能。** 由於填充碼會在執行階段重寫程式碼，因此執行得比較慢。 虛設常式類型沒有這樣的效能負荷，執行速度與虛擬方法一樣快。

**靜態方法，密封類型。** 您只能使用虛設常式實作介面。 因此，虛設常式類型不能用於靜態方法、非虛擬方法、密封虛擬方法、密封類型中的方法等等。

**內部類型。** 虛設常式和填充碼都可以搭配使用組件屬性 <xref:System.Runtime.CompilerServices.InternalsVisibleToAttribute> 存取的內部類型一起使用。

**私用方法。** 如果方法簽章的所有類型都是可見的，填充碼可以取代私用方法呼叫。 虛設常式只能取代可見的方法。

**介面和抽象方法。** 虛設常式提供可用於測試的介面和抽象方法實作。 填充碼無法檢測介面和抽象方法，因為它們沒有方法主體。

一般而言，我們建議您使用虛設常式類型與程式碼基底中的相依性隔離。 您可以藉由將元件隱藏在介面後面來達成。 您可以使用填充碼類型隔離不提供可測試之應用程式開發介面的協力廠商元件。

## <a name="get-started-with-stubs"></a>開始使用虛設常式
如需更詳細的描述，請參閱[使用虛設常式隔離應用程式的各個組件，方便進行單元測試](../test/using-stubs-to-isolate-parts-of-your-application-from-each-other-for-unit-testing.md)。

1. **插入介面**

     若要使用虛設常式，您所撰寫的測試程式碼不可明確提及應用程式其他元件中的類別。 「元件」是指一併開發及更新的一個或多個類別，通常會包含在一個 Visual Studio 專案中。 應使用介面宣告變數和參數，並應使用 Factory 傳入或建立其他元件的執行個體。 例如，如果 StockFeed 是另一個應用程式元件中的類別，下列作法就不正確：

     `return (new StockFeed()).GetSharePrice("COOO"); // Bad`

     相反地，請定義可由另一個元件或測試虛設常式實作的介面：

    ```csharp
    public int GetContosoPrice(IStockFeed feed) => feed.GetSharePrice("COOO");
    ```

    ```vb
    Public Function GetContosoPrice(feed As IStockFeed) As Integer
     Return feed.GetSharePrice("COOO")
    End Function

    ```

2. **新增 Fakes 組件**

   1. 在 **方案總管** 中， 
       - 針對較舊的 .NET Framework 專案 (非 SDK 樣式) ，請展開您的單元測試專案的 [ **參考** ] 節點。
       ::: moniker range=">=vs-2019"
       - 若為以 .NET Framework 或 .NET Core 為目標的 SDK 樣式專案，請展開 [相依性 **]** 節點，以尋找您想要在 **元件**、 **專案** 或 **封裝** 下偽造的元件。
       ::: moniker-end
       - 如果您是在 Visual Basic 中工作，請選取 [**方案總管**] 工具列中的 [**顯示所有** 檔案]，以查看 [**參考**] 節點。
   2. 選取包含您要為其建立填充碼之類別定義的元件。 例如，如果您想要填充碼 **DateTime**，請選取 [ **System.dll**]。

   3. 在捷徑功能表上，選擇 [新增 Fakes 組件]。

3. 在您的測試中，建構虛設常式的執行個體，並為其方法提供程式碼：

    ```csharp
    [TestClass]
    class TestStockAnalyzer
    {
        [TestMethod]
        public void TestContosoStockPrice()
        {
          // Arrange:

            // Create the fake stockFeed:
            IStockFeed stockFeed =
                 new StockAnalysis.Fakes.StubIStockFeed() // Generated by Fakes.
                     {
                         // Define each method:
                         // Name is original name + parameter types:
                         GetSharePriceString = (company) => { return 1234; }
                     };

            // In the completed application, stockFeed would be a real one:
            var componentUnderTest = new StockAnalyzer(stockFeed);

          // Act:
            int actualValue = componentUnderTest.GetContosoPrice();

          // Assert:
            Assert.AreEqual(1234, actualValue);
        }
        ...
    }
    ```

    ```vb
    <TestClass()> _
    Class TestStockAnalyzer

        <TestMethod()> _
        Public Sub TestContosoStockPrice()
            ' Arrange:
            ' Create the fake stockFeed:
            Dim stockFeed As New StockAnalysis.Fakes.StubIStockFeed
            With stockFeed
                .GetSharePriceString = Function(company)
                                           Return 1234
                                       End Function
            End With
            ' In the completed application, stockFeed would be a real one:
            Dim componentUnderTest As New StockAnalyzer(stockFeed)
            ' Act:
            Dim actualValue As Integer = componentUnderTest.GetContosoPrice
            ' Assert:
            Assert.AreEqual(1234, actualValue)
        End Sub
    End Class

    ```

    這裡最特別的是 `StubIStockFeed` 類別。 Microsoft Fakes 機制會針對參考組件中的每一個介面產生虛設常式類別。 存根類別的名稱衍生自介面的名稱，並以 " `Fakes.Stub` " 做為前置詞，並附加參數類型名稱。

    另外也會為屬性、事件及泛型方法的 getter 及 setter 產生虛設常式。 如需詳細資訊，請參閱[使用虛設常式隔離應用程式的各個組件，方便進行單元測試](../test/using-stubs-to-isolate-parts-of-your-application-from-each-other-for-unit-testing.md)。

## <a name="get-started-with-shims"></a>開始使用填充碼
(如需更詳細的描述，請參閱[使用填充碼將應用程式與其他組件隔離，方便進行單元測試](../test/using-shims-to-isolate-your-application-from-other-assemblies-for-unit-testing.md)。)

假設您的元件包含對 `DateTime.Now` 的呼叫：

```csharp
// Code under test:
    public int GetTheCurrentYear()
    {
       return DateTime.Now.Year;
    }
```

在測試期間，您要填充 `Now` 屬性，因為真實版本會在每次呼叫時傳回不同的值，非常不方便。

若要使用填充碼，就不需要修改應用程式程式碼或以特別方式撰寫程式碼。

1. **新增 Fakes 組件**

     在 **方案總管** 中，開啟單元測試專案的參考，然後選取包含您要假之方法的元件參考。 在本範例中，`DateTime` 類別是在 *System.dll* 中。  若要查看 Visual Basic 專案中的參考，請選擇 [顯示所有檔案]。

     選擇 [新增 Fakes 組件]。

2. **在 ShimsContext 中插入填充碼**

    ```csharp
    [TestClass]
    public class TestClass1
    {
            [TestMethod]
            public void TestCurrentYear()
            {
                int fixedYear = 2000;

                // Shims can be used only in a ShimsContext:
                using (ShimsContext.Create())
                {
                  // Arrange:
                    // Shim DateTime.Now to return a fixed date:
                    System.Fakes.ShimDateTime.NowGet =
                    () =>
                    { return new DateTime(fixedYear, 1, 1); };

                    // Instantiate the component under test:
                    var componentUnderTest = new MyComponent();

                  // Act:
                    int year = componentUnderTest.GetTheCurrentYear();

                  // Assert:
                    // This will always be true if the component is working:
                    Assert.AreEqual(fixedYear, year);
                }
            }
    }
    ```

    ```vb
    <TestClass()> _
    Public Class TestClass1
        <TestMethod()> _
        Public Sub TestCurrentYear()
            Using s = Microsoft.QualityTools.Testing.Fakes.ShimsContext.Create()
                Dim fixedYear As Integer = 2000
                ' Arrange:
                ' Detour DateTime.Now to return a fixed date:
                System.Fakes.ShimDateTime.NowGet = _
                    Function() As DateTime
                        Return New DateTime(fixedYear, 1, 1)
                    End Function

                ' Instantiate the component under test:
                Dim componentUnderTest = New MyComponent()
                ' Act:
                Dim year As Integer = componentUnderTest.GetTheCurrentYear
                ' Assert:
                ' This will always be true if the component is working:
                Assert.AreEqual(fixedYear, year)
            End Using
        End Sub
    End Class
    ```

    填充碼類別名稱是在原始類型名稱前面加上 `Fakes.Shim` 而構成。 方法名稱後面要加上參數名稱。 (您不必將任何組件參考加入 System.Fakes)。

上述範例使用靜態方法的填充碼。 若要使用填充碼做為執行個體方法，請在類型名稱和方法名稱之間撰寫 `AllInstances`：

```vb
System.IO.Fakes.ShimFile.AllInstances.ReadToEnd = ...
```

(沒有任何 'System.IO.Fakes' 組件可參考。 此命名空間是填充碼建立處理序所產生的。 但您可以按照一般方式使用 'using' 或 'Import')。

您也可以為特定執行個體、建構函式和屬性建立填充碼。 如需詳細資訊，請參閱[使用填充碼將應用程式與其他組件隔離，方便進行單元測試](../test/using-shims-to-isolate-your-application-from-other-assemblies-for-unit-testing.md)。

## <a name="using-microsoft-fakes-in-the-ci"></a>在 CI 中使用 Microsoft Fakes

### <a name="microsoft-fakes-assembly-generation"></a>產生元件 Microsoft Fakes
因為 Microsoft Fakes 需要 Visual Studio Enterprise，所以 Fakes 元件的產生需要您使用 [Visual Studio 組建](/azure/devops/pipelines/tasks/build/visual-studio-build?view=azure-devops&preserve-view=true)工作來建立您的專案。

::: moniker range=">=vs-2019"
> [!NOTE]
> 另一個方法是將您的 Fakes 元件簽入 CI，並使用 [MSBuild](../msbuild/msbuild-task.md?view=vs-2019&preserve-view=true)工作。 當您這樣做時，您必須確定您的測試專案中有產生之 Fakes 元件的元件參考，如下列程式碼片段所示：

```xml
<Project Sdk="Microsoft.NET.Sdk">
    <ItemGroup>
        <Reference Include="FakesAssemblies\System.Fakes.dll">
    </ItemGroup>
</Project>
```

您必須以手動方式將 SDK 樣式的專案加入此參考， ( .NET Core 和 .NET Framework) ，因為我們已移至隱含地將元件參考加入至您的測試專案。 如果您遵循此方法，則必須確保在父元件變更時，會更新 fakes 元件。
::: moniker-end

### <a name="running-microsoft-fakes-tests"></a>正在執行 Microsoft Fakes 測試
只要 Microsoft Fakes 的元件存在於設定的目錄中 `FakesAssemblies` (預設 `$(ProjectDir)FakesAssemblies`) ，您就可以使用 [vstest](/azure/devops/pipelines/tasks/test/vstest?view=azure-devops&preserve-view=true)工作執行測試。

::: moniker range=">=vs-2019"
使用 Microsoft Fakes 以 [vstest](/azure/devops/pipelines/tasks/test/vstest?view=azure-devops&preserve-view=true) 工作 .net Core 專案進行分散式測試需要 Visual Studio 2019 Update 9 Preview `20201020-06` 和更新版本。
::: moniker-end

::: moniker range=">=vs-2019"
## <a name="transitioning-your-net-framework-test-projects-that-use-microsoft-fakes-to-sdk-style-net-framework-or-net-core-projects"></a>將使用 Microsoft Fakes 的 .NET Framework 測試專案轉換成 SDK 樣式 .NET Framework 或 .NET Core 專案
您將需要 .NET Framework 設定的最少量變更，讓 Microsoft Fakes 轉換為 .NET Core。 您必須考慮的案例如下：
- 如果您使用的是自訂專案範本，您必須確定它是 SDK 樣式，而且是針對相容的目標 framework 所建立。
- 某些型別存在於 .NET Framework 和 .net core 的不同元件中 (例如，存在於 .NET Framework 中， `System.DateTime` `System` / `mscorlib` 以及在 `System.Runtime` .net core) 中，而在這些情況下，您必須將元件變更為偽造。
- 如果您有 fakes 元件和測試專案的元件參考，您可能會看到有關遺漏參考的組建警告，如下所示：
  ```
  (ResolveAssemblyReferences target) ->
  warning MSB3245: Could not resolve this reference. Could not locate the assembly "AssemblyName.Fakes". Check to make sure the assembly exists on disk.
  If this reference is required by your code, you may get compilation errors.
  ```
  這項警告是因為可以忽略 Fakes 產生中所做的必要變更。 您可以藉由移除專案檔中的元件參考來避免這種情況，因為我們現在會在組建期間隱含地加入元件參考。
::: moniker-end

## <a name="microsoft-fakes-support"></a>Microsoft Fakes 支援 
### <a name="microsoft-fakes-in-older-projects-targeting-net-framework-non-sdk-style"></a>以 .NET Framework (非 SDK 樣式) 為目標的舊版專案中 Microsoft Fakes。
- Visual Studio Enterprise 2015 和更新版本支援 Microsoft Fakes 元件產生。
- Microsoft Fakes 的測試可以搭配所有可用的 TestPlatform NuGet 套件來執行。
- 使用 Visual Studio Enterprise 2015 和更新版本中 Microsoft Fakes 的測試專案支援程式碼涵蓋範圍。

### <a name="microsoft-fakes-in-sdk-style-net-framework-and-net-core-projects"></a>SDK 樣式 .NET Framework 和 .NET Core 專案中的 Microsoft Fakes
- Microsoft Fakes 在 Visual Studio Enterprise 2019 Update 6 中預覽的元件產生，在 Update 8 中預設為啟用。
- 針對以 .NET Framework 為目標的專案 Microsoft Fakes 測試可以搭配所有可用的 TestPlatform NuGet 套件來執行。
- 針對以 .NET Core 為目標的專案，Microsoft Fakes 測試可以搭配 Microsoft 執行。 TestPlatform NuGet 套件的版本 [16.8.0-preview-20200921-01](https://www.nuget.org/packages/Microsoft.TestPlatform/16.8.0-preview-20200921-01) 和更新版本。
- 使用 Visual Studio Enterprise 2015 版和更高版本中的 Microsoft Fakes，以 .NET Framework 為目標的測試專案支援程式碼涵蓋範圍。
- 使用 Microsoft Fakes 以 .NET Core 為目標之測試專案的程式碼涵蓋範圍支援正在開發中。


## <a name="in-this-section"></a>本節內容
[使用虛設常式隔離應用程式的各個組件，以便進行單元測試](../test/using-stubs-to-isolate-parts-of-your-application-from-each-other-for-unit-testing.md)

[使用填充碼將應用程式與其他組件隔離，方便進行單元測試](../test/using-shims-to-isolate-your-application-from-other-assemblies-for-unit-testing.md)

[Microsoft Fakes 中的程式碼產生、編譯和命名慣例](../test/code-generation-compilation-and-naming-conventions-in-microsoft-fakes.md)
